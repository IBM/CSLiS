#!/bin/bash
#
# Copyright 2022 - IBM Inc. All rights reserved
# SPDX-License-Identifier: LGPL-2.1
#

Configure_version="4.900 01/21/20"

if [ -f /proc/kallsyms ]; then
    KSYMS=/proc/kallsyms
else
    KSYMS=/proc/ksyms
fi

## DEBUG
# set -x

usage()
{
cat <<EOF

NAME
       Configure -- configure script for Linux Streams.

SYNOPSIS
       Configure [options] [<config output file name>]

DESCRIPTION
       Collect Linux streams configuration. Interactively by default or
       option parsing.

OPTIONS
       -h,--help Print out this message
       -m|--onmachine Install on this machine [y|n required]
       -l|--levelrun Configure to run in :
                     l=kernel,u=userspace,q=QNX
       -n|--nativecompiler Use native C (or cross compiling) [y|n required] 
       -r|--onrunning Compile on current running kernel [y|n required]
       -s|--ksourcedir Kernel source directory <STRING>
       -v|--versionlinux  Kernel version <STRING> (uname -r) 
       -M|--loadmodules If answer is no must run 'make modules_install' to
                        install modules [y|n required]
       -L|--moduleslocation  Kernel modules location <STRING>
       -b|--backcompat [y|N optional]
                       y =  LiS backward compatible constants 
                       n =  UnixWare/Solaris compatible constants 
       -S|--solaris Use Solaris style cmn_err [y|N optional]
       -g|--sourcedebug Source level debugging [y|n optional]
       -R|--sharedlibs Use shared libraries [Y|n required]
       -c|--intcpuflags  "int or unsigned long" type for CPU [y|n required] 
       -i|--forcenewinode Force new_inode usage (only when not detected)
                       [y|n optional]
       -p|--productioncode Performance enhanced production code [y|n required]
       -I|--inet Attempt to build 'streams-inet' kernel module
       -D|--devbase  Base major device number [value required]
       -N|--noprompt  Don't prompt for options; use defaults
       -t|--comment  Comment text
       -q|--quiet   No console output
       -x|--make    Invoked from 'make'
       -o|--output  Output file name [config.in]
       --pkgcompile Compile (.c) sources in pkg subdirs
       --pkgmodules Build compiled objects in pkg subdirs as modules
       --package	short name of package [LiS]
       --prefix		generic install directory prefix [/usr]
       --execprefix	install prefix for executables [/usr]
       --includedir	where to install gemeric headers [/usr/include]
       --libdir		where to install generic libraries [/usr/lib]
       --bindir		where to install user executables [/usr/bin]
       --sbindir	where to install system executables [/usr/sbin]
       --sysconfdir	where to install system configuration files [/etc]
       --datadir	where to install package-specific subdirs [/usr/share]
       --pkgincludedir	where to install package headers [/usr/include/LiS]
       --pkglibdir	where to install package libraries [/usr/lib/LiS]
       --pkgdatadir	where to install package files [/usr/share/LiS]
       --pkgsrcdir	where to install package sources [/usr/src/LiS]
       --mandir		where to install man pages [/usr/share/man]
       --modsubdir	where to install kernel modules [streams]
       --regparm        0 or 3 for STREAMS regparm interface [0]

EXAMPLE 

 ./Configure --onmachine=n --levelrun=l --nativecompiler=y --onrunning=n 
 --ksourcedir=/usr/src/kernel-headers-2.4.22-1-686-smp 
 --versionlinux=2.4.22-1-686-smp    --loadmodules=n 
 --moduleslocation=/lib/modules/2.4.22-1-686-smp/ --backcompat=n 
 --solaris=n --sourcedebug=y --sharedlibs=y --intcpuflags=n --forcenewinode=y 
 --productioncode=y

EOF
}

setup_opts ()
{
    declare -a opts

    save_IFS=$IFS
    opts=( \
	"onmachine:" "levelrun:" "nativecompiler:" "onrunning:"		\
	"ksourcedir:" "versionlinux:" "loadmodules:" "moduleslocation:" \
	"backcompat::" "solaris::" "sourcedebug::" "sharedlibs:" 	\
	"intcpuflags:" "forcenewinode::" "productioncode:" "inet" 	\
	"noprompt" "devicebase:" "output:" "comment:" "make" "quiet" 	\
	"help" "package:" "prefix:" "execprefix:" "includedir:"		\
	"libdir:" "bindir:" "sbindir:" "sysconfdir:" "datadir:"		\
	"pkgincludedir:" "pkglibdir:" "pkgdatadir:" "pkgsrcdir:"	\
	"mandir:" "modsubdir:" "pkgcompile" "pkgmodules" "regparm:"	\
    )
    IFS=","
    longopts="${opts[*]}"
    IFS=$save_IFS
    opts=(\
	"m:" "l:" "n:" "r:" "s:" "v:" "M:" "L:" "b::" "S::" "g::" "R:" \
	"c:" "i::" "p:" "I" "N" "D:" "o:" "t:" "x" "q" "h" )
    IFS=""
    shortopts="${opts[*]}"
    IFS=$save_IFS
}

#=======================================================================
#
# Parse command line options
#

# save options passed in as CONFIG_OPTS
#
CONFIG_OPTS="${*}"

# setup longopts and shortopts
#
setup_opts

# let getopt(1) do its thing...  we use args to be able to preserve
# getopt's exit code.  Thereafter, we convert args to positional parms
# with 'eval set --'
#
args=`getopt -n $(basename $0) -l $longopts -o $shortopts -- "$@"`
if [ $? != 0 ]; then exit 1; fi
eval set -- "$args"

## Set shell variables from parsed options
##
while  true ; do
case "$1" in
    -m|--onmachine) OPT_ONMACHINE=$2; shift 2;;
    -l|--levelrun) OPT_LEVELRUN=$2; shift 2;;
    -n|--nativecompiler) OPT_NATIVECOMPILER=$2; shift 2 ;;
    -r|--onrunning) OPT_ONRUNNINGLNX=$2; shift 2 ;;
    -s|--ksourcedir) OPT_KSOURCEDIR=$2; shift 2 ;;
    -v|--versionlinux) OPT_VERSIONLINUX=$2; shift 2 ;;
    -M|--loadmodules) OPT_LOADMODULES=$2; shift 2 ;;
    -L|--moduleslocation) OPT_MODULESLOCATION=$2; shift 2 ;;
    -b|--backcompat) OPT_BACKCOMPAT=${2:-y}; shift 2 ;;
    -S|--solaris) OPT_SOLARISSTYLE=${2:-y}; shift 2 ;;
    -g|--sourcedebug) OPT_SRCDBG=${2:-y}; shift 2 ;;
    -R|--sharedlibs) OPT_SHAREDLIBS=$2; shift 2 ;;
    -c|--intcpuflags) OPT_INTCPUFLAGS=$2; shift 2 ;;
    -i|--forcenewinode) OPT_FORCENEWINODE=${2:-y}; shift 2 ;;
    -p|--productioncode) OPT_PRODUCTIONCODE=$2; shift 2 ;;
    -I|--inet) OPT_INET=y; shift ;;
    -D|--devicebase) OPT_DEVICEBASE=$2; shift 2 ;;
    -N|--noprompt) OPT_NOPROMPT=y; shift ;;
    -o|--output) OPT_CONFIG=$2; shift 2 ;;
    -t|--comment) COMMENT="$COMMENT$2"; shift 2 ;;
    -x|--make) MAKE_INVOKED=y;  shift ;;
    -q|--quiet) QUIET=y;  shift ;;
    -h|--help) usage ; exit 0;;
    --pkgcompile) OPT_PKGCOMPILE=y; shift ;;
    --pkgmodules) OPT_PKGMODULES=y; shift ;;
    --package) package=$2; shift 2 ;;
    --prefix) prefix=${2:-" "}; shift 2 ;;
    --execprefix) execprefix=${2:-" "}; shift 2 ;;
    --includedir) includedir=$2; shift 2 ;;
    --libdir) libdir=$2; shift 2 ;;
    --bindir) bindir=$2; shift 2 ;;
    --sbindir) sbindir=$2; shift 2 ;;
    --sysconfdir) sysconfdir=$2; shift 2 ;;
    --datadir) datadir=$2; shift 2 ;;
    --pkgincludedir) pkgincludedir=$2; shift 2 ;;
    --pkglibdir) pkglibdir=$2; shift 2 ;;
    --pkgdatadir) pkgdatadir=$2; shift 2 ;;
    --pkgsrcdir) pkgsrcdir=${2:-" "}; shift 2 ;;
    --mandir) mandir=$2; shift 2 ;;
    --modsubdir) modsubdir=$2; shift 2 ;;
    --regparm) STREAMS_REGPARM=$2; shift 2 ;;
    --) shift; break ;;
    *) echo "$(basename $0): unrecognized option '$1'" >&2; exit 1 ;;
    esac
done

# we expect zero or one unparsed argument, to be used as the file
# name for this script's output.  We need to verify this; if there's
# more than one, the first may be an improperly parsed option or
# option value.
#
if [ $# -gt 1 ]; then
    echo "error - expected <config output file name>" >&2
    exit 1
fi

# set CONFIG - priority to -o|--output <file>, but last arg otherwise;
# default to 'config.in'.  The reason for this priority is that using
# -o|--output ensures no mistake in specifying the file name, but still
# allows optional arguments to be used
#
CONFIG=${OPT_CONFIG:-${1:-config.in}}

# set qecho/qcat to be used for output controlled by QUIET option
#
if [ "$QUIET" = "y" ]; then qecho=: ; qcat=: ; else qecho=echo ; qcat=cat ; fi

#=========================================================================

# argn() usage: argn <n> <args>...
#
argn()
{
    n=$1;  shift;  echo -n $(eval "echo -n \$$n")
}

#
# do_readstring  - Ask for a string
#
# Inputs:
# 	PROMPT has the string to prompt the user with.
#	DEFAULT is the default response to use for empty input
# Outputs:
#	RESULT has the response from the user
#
do_readstring()
{
    if [ -n "$OPT_NOPROMPT" ]; then
	RESULT=$DEFAULT
	return
    fi

    while true; do
	echo -en "\n$PROMPT "
	if [ "$DEFAULT..." != "..." ]; then
	    echo -n "[default: $DEFAULT] "
	fi

	read RESULT

	if [ "$RESULT..." != "..." ]; then
	    return
	else
	    if [ "$DEFAULT..." != "..." ]; then
		RESULT=$DEFAULT
	        return
	    fi
	fi
    done
}

#
# Write a message to the user and get a CR to continue
#
do_confirm()
{
    if [ -n "$OPT_NOPROMPT" ]; then
	return
    fi

    PROMPT="$1"
    if [ "$1..." != "..." ]; then
	PROMPT="$PROMPT  "
    fi
    PROMPT="${PROMPT}Press Enter to continue... "
    echo -en "\n$PROMPT"
    read DISCARD
}

#
# do_read_dir  - Ask for name of an existing directory
#
# Inputs:
# 	PROMPT has the string to prompt the user with.
#	DEFAULT is the default response to use for empty input
#       ARGVVALUE is the value collected by ARG parsing -> no interaction
# Outputs:
#	RESULT has the response from the user
#
do_read_dir()
{
    if [ -n "$OPT_NOPROMPT" ]; then
	[ -d "$ARGVALUE" ] && DEFAULT=$ARGVALUE
	do_readstring
	if [ -d "$RESULT" ]; then
	    return 0
	else
	    return 1
        fi
    fi

    n=2
    while :; do
	if [ "$ARGVVALUE..." = "..." ]; then
            #interact with user..
            do_readstring
        else
	    RESULT=${ARGVVALUE}
            # to avoid loops
	    unset ARGVVALUE 
        fi
	if [ -d "$RESULT" ]; then
	    return 0
	fi
	n=`expr $n - 1`
	if [ $n -eq 0 ]; then
	    return 1
	fi
    done
}

#
# do_read_choice  - Ask for a choice
#
# Inputs:
# 	PROMPT has the string to prompt the user with.
#	RESPONSE has the responses that are valid
#       ARGVVALUE is the value collected by ARG parsing -> no interaction
#	DEFAULT is the default response to use for empty input
# Outputs:
#	RESULT has the response from the user
#
do_read_choice()
{
    if [ -n "$OPT_NOPROMPT" ]; then
	RESULT=${ARGVVALUE:-$DEFAULT}
	return
    fi

    # Check that we have valid responses and default
    if [ "$RESPONSE..." = "..." ]; then
	echo "Internal error."
	exit 1;
    fi
    local VALID_DEFAULT=0
    for i in $RESPONSE; do
        if [ "$ALTERNATE_DEFAULT..." = "..." ]; then
	    local ALTERNATE_DEFAULT=$i
	fi
        if [ "$i" = "$DEFAULT" ]; then
    	    local VALID_DEFAULT=1
	    break
        fi
    done
    if [ "$VALID_DEFAULT" = "0" ]; then
	DEFAULT=
    fi
    if [ "$DEFAULT..." = "..." ]; then
	DEFAULT=$ALTERNATE_DEFAULT
    fi

    while :; do
        if [ "$ARGVVALUE..." = "..." ]; then
         #interact with user..
         do_readstring
         else
         # use the response from CLI
         RESULT=${ARGVVALUE}
        # to avoid loop
        unset  ARGVVALUE
         fi
	for i in $RESPONSE; do
	    if [ "$i" = "$RESULT" ]; then
		return
	    fi
	done
	echo "Unexpected response"
    done
}

#
# default_ksrc
#
# Figure out a good default for kernel source directory
# Do not retain any "../" isms in the path name.
#
default_ksrc()
{
    kver=${OPT_VERSIONLINUX:-`uname -r`}
    # On SuSE 10, build does not include all the source we need.  source
    # does, but only after installing the kernel source.  source is also a
    # better option as it points to the same place as /usr/src/linux and
    # will more likely reflect the actual running kernel if there is a custom
    # on in place.  build never changes, no matter you do.  On RH, both
    # source and build point to the same place.
    if [ -d /lib/modules/${kver}/build ]; then
        KBIN=/lib/modules/${kver}/build
        if [ -f /lib/modules/${kver}/build/include/linux/sched.h ]; then
            KSRC=/lib/modules/${kver}/build
        else
            KSRC=/lib/modules/${kver}/source
        fi
    fi

    if [ ! -d $KSRC ]; then
 	kver=`uname -r`
        if [ -d /lib/modules/${kver}/build ]; then
            KBIN=/lib/modules/${kver}/build
            if [ -f /lib/modules/${kver}/build/include/linux/sched.h ]; then
                KSRC=/lib/modules/${kver}/build
            else
                KSRC=/lib/modules/${kver}/source
            fi
        fi
    fi

    # change symbolic links to the real directories
    if [ -L $KBIN ]; then
	KBIN=`ls -l $KBIN | sed -e 's/^.*-> //' -e 's/\.\.\//\//g'`
    fi

    if [ -L $KSRC ]; then
	KSRC=`ls -l $KSRC | sed -e 's/^.*-> //' -e 's/\.\.\//\//g'`
        if [ ! -d "$KSRC" -a ! -L "$KSRC" ]; then
	    KSRC=Unknown
	fi
    elif [ -d /usr/src/linux -o -L /usr/src/linux ]; then
        KSRC=/usr/src/linux
    else
        KSRC=Unknown
    fi
    #  echo out result
    $qecho \
"KBIN is $KBIN"
}

#
# check_ksrc
#
# Check to see if the directory $KSRC is present.  If it is set to
# /usr/src/linux and that directory is not present then feel around
# a bit for a substitute to which a symbolic link can be constructed.
#
check_ksrc()
{
    if [ -n "$KSRC" ]; then

	if [ -d "$KSRC" ]; then
	    return 0				# present
	fi

	if [ -L "$KSRC" ]; then
	    (cd $KSRC >/dev/null 2>&1) && return 0 || return 1
	    # return 0			# symbolic link, presume present
	fi

	if [ "$KSRC" != "/usr/src/linux" ]; then
	    # FIXME - why fail if /usr/src/linux is a directory?
	    return 1				# not present
	fi
    fi

    #
    # pick up version string.  It might be like "2.4.2" or it
    # might be like "2.4.2-21smp".
    #
    # - the following (now) works, but `uname -r` is easier...
    #vers=("`cat /proc/version | sed 's:(::g' | sed 's:)::g'`")
    #vers=`argn 3 ${vers}`
    #
    vers=`uname -r`
    trunc_vers=`echo $vers | sed -e 's/-.*//'`
    num_vers=`echo $vers | sed -e 's/[a-zA-Z][a-zA-Z]*//'`

    if [ -d /lib/modules/${vers}/build ]; then
	KSRC=/lib/modules/${vers}/build
    elif [ -d /usr/src/$vers ]; then
	KSRC=/usr/src/$vers
    elif [ -d /usr/src/linux-$vers ]; then
	KSRC=/usr/src/linux-$vers
    elif [ -d /usr/src/linux$trunc_vers ]; then
	KSRC=/usr/src/linux$trunc_vers
    elif [ -d /usr/src/linux-$trunc_vers ]; then
	KSRC=/usr/src/linux-$trunc_vers
    elif [ -d /usr/src/linux$num_vers ]; then
	KSRC=/usr/src/linux$num_vers
    elif [ -d /usr/src/linux-$num_vers ]; then
	KSRC=/usr/src/linux-$num_vers
    else
	return 1				# not present
    fi

    return 0					# present
}

#
# Get config variable from config.h/autoconf.h.  If config.h is not present
# or does not have the config variable, try the "include/config" 
# subdirectory.
#
# $1 is the name of the variable to find.
#
# Return via stdout a "y" if defined or "" if not.
#
ac_get_config()
{
    if [ -f $KSRC/include/linux/utsrelease.h ]; then
        if [[ $(grep utsrelease dummy.c) != 0 ]]; then
            echo "#include <linux/utsrelease.h>" >> dummy.c
        fi
    elif [ -f $KBIN/include/generated/utsrelease.h ]; then
        if [[ $(grep utsrelease dummy.c) != 0 ]]; then
            echo "#include <generated/utsrelease.h>" >> dummy.c
        fi
    else
        echo "KSRC/include/linux/utsrelease.h failed: $KSRC"
    fi

    if [ -f $KSRC/include/linux/config.h ]; then
	cc -D__KERNGLUE__ -I$KSRC/include -E -dM \
		-include $KSRC/include/linux/config.h dummy.c > /tmp/kconfig
	x=`grep $1 /tmp/kconfig 2>&1`
	if [ $? -eq 0 ]; then			# found it
	    if expr "$x" : "#define" >/dev/null 2>/dev/null; then
		echo -n "y"			# option selected
		return 0			# found
	    fi
	    if expr "$x" : "#undef" >/dev/null 2>/dev/null; then
		return 0			# found, but empty
	    fi
	fi
	#
	# If autoconf.h is present but our option is not mentioned
	# in a #define, then it must be in a #undef.  So assume
	# that the option is "found" but not set.
	#
	return 0				# found, but empty

    else
        echo "KSRC/include/linux/config.h failed: $KSRC"

    fi
						# no autoconf.h
    return 1					# not found
}

#
# Get config variable from .config
#
# $1 is the name of the variable to find, of the form "VAR=y".
#
# Return via stdout a "y" if defined or "" if not.
#
dc_get_config()
{
    x=`grep $1 $KSRC/.config 2>&1`
    if [ $? -ne 0 ]; then
	return 1
    fi
    echo -n "y"
    return 0			# found
}

#
# Get System.map file name on a Red Hat system
# 5.2 has one of them in /boot, 6.0 has several with a symbolic
# link from System.map to the one that is in use.
#
# This is only meaningful if the user intends to run LiS on the
# machine on which he is installing it.  So ask first.
#
# Return 0 (true) if found
#
rh_get_system_map()
{
    if [ "$BEEN_HERE_DONE_THIS..." = "1..." ]; then
	if [ "$SMAP..." = "..." ]; then
	    return 1
	fi
	return 0
    fi

    SMAP=
    PROMPT="\
Is it your intent to run LiS on the same machine on which\n\
you are installing it?  Or are you intending to cross compile\n\
for another machine?\n\
    y = I am going to run it on this machine\n\
    n = I am not going to run it on this machine\n\
Please enter y or n"
    RESPONSE="y n"
    DEFAULT=y
    ARGVVALUE="$OPT_ONMACHINE"
    do_read_choice
    BEEN_HERE_DONE_THIS=1
    if [ "$RESULT..." = "n..." ]; then
	echo
	echo "You really should load your kernel source and build"
	echo "your kernel before installing LiS."
	echo
	do_confirm
	return 1
    fi

    if [ ! -d /boot ]; then
	return 1
    fi
    if [ ! -L /boot/System.map ]; then
	files=`ls /boot/System.map*`
	if [ $? -ne 0 ]; then
	    return 1
	fi
	nfiles=0
	for i in $files; do
	    nfiles=`expr $nfiles + 1`
	done
	if [ $nfiles -ne 1 ]; then	# need just one of them
	    return 1
	fi

	SMAP=$i				# save file name
    else				# it's a symbolic link
	SMAP=/boot/System.map
    fi
    return 0
}

#
# Check for places that version.h may be hiding.  Try to establish it
# in the kernel source tree where it belongs.
#
check_kver()
{
    #
    # SuSE 7.2 lacks a version.h in the kernel source tree but has one
    # in /boot -- presumably paired with the running kernel version.
    # We will attempt to copy it if it is there and not care whether or
    # not the copy fails.  If we need a version.h in kernel source and
    # it isn't there then we will just write a message and terminate the
    # install.
    #
    if [    ! -f $KSRC/include/linux/version.h \
    	 -a -f /boot/vmlinuz.version.h \
	 -a -d $KSRC/include/linux \
       ]
    then
	cp /boot/vmlinuz.version.h $KSRC/include/linux/version.h \
		>/dev/null 2>/dev/null
    fi
    #
    # RHEL 7 lacks a version.h in the kernel source tree default
    # so look in generate/uapi/linux directory.
    # We will attempt to copy it if it is there and not care whether or
    # not the copy fails.  If we need a version.h in kernel source and
    # it isn't there then we will just write a message and terminate the
    # install.
    #
    if [    ! -f $KSRC/include/linux/version.h \
    	 -a -f $KSRC/include/generated/uapi/linux/version.h \
	 -a -d $KSRC/include/linux \
       ]
    then
	cp $KSRC/include/generated/uapi/linux/version.h $KSRC/include/linux/version.h \
		>/dev/null 2>/dev/null
    fi
}

#
# Try to extract the kernel version info from the version.h file
# The argument is the full pathname of the version.h file to extract
# from.
#
get_vers_h()
{
#
#  SuSE split 2.6.27.48 release on a maintenance level into 2 paths
#  for the Linux kernel source. These ckecks were added to find
#  where utsrelease.h is residing
#
#     echo "inside get_vers_h()"
#     echo "KSRC = $KSRC"
#     echo "KBIN = $KBIN" 

    GET_VERS_H=0
    if [ -f $KSRC/include/linux/utsrelease.h ]; then
        if [[ $(grep utsrelease dummy.c) != 0 ]]; then
#            echo "inside linux test $KSRC"
            echo "#include <linux/utsrelease.h>" >> dummy.c
            GET_VERS_H=1
        fi
    elif [ -f $KBIN/include/linux/utsrelease.h ]; then
        if [[ $(grep utsrelease dummy.c) != 0 ]]; then
#            echo "inside linux test $KBIN"
            echo "#include <linux/utsrelease.h>" >> dummy.c
            GET_VERS_H=1
        fi
    elif [ -f $KBIN/include/generated/utsrelease.h ]; then
        if [[ $(grep utsrelease dummy.c) != 0 ]]; then
#            echo "inside linux test $KBIN/generated"
            echo "#include <generated/utsrelease.h>" >> dummy.c
            GET_VERS_H=1
        fi
     else
         echo " ...-f $KSRC/include/linux/utsrelease.h failed"
         echo " ...-f $KBIN/include/linux/utsrelease.h failed" 
     fi

#     echo "GET_VERS_H is $GET_VERS_H"

    if [ -f $1 ]; then
#        echo " this test is for $1"
	cc -D__KERNGLUE__ -I$KSRC/include -I$KBIN/include -E -dM -include $1 dummy.c > /tmp/kver
	KVER_H=`grep UTS_RELEASE /tmp/kver | \
	     sed -e 's/^.*UTS_RELEASE.//' -e's/"//g' -e's/  *$//'`
	NKVER_H=`echo $KVER_H | sed -e 's/-.*//'`
#        echo "KVER_H set to $KVER_H "
    fi
}

#
# parse the kernel version identifier into its components
#
# $1 is the kernel version string
#
parse_kver()
{

KVERPATCHTMP=${KVER%%-*}
number_of_fields=$(echo $KVERPATCHTMP | grep -o "\." | wc -l)
if [ $number_of_fields -gt 2 ]
then
  KVERPATCH=${KVERPATCHTMP%.*}
else
  KVERPATCH=${KVERPATCHTMP}
fi
KVER_MAJORMINOR=${KVERPATCH%.*}
KVER_MAJOR=${KVERPATCH%${KVERPATCH#*[^.]}}
KVER_MINOR=${KVER_MAJORMINOR#*.}
KVER_PATCHNO=${KVERPATCH##*.}

echo "KVER: $KVER"
# echo "KVERPATCHTMP: $KVERPATCHTMP"
# echo "KVERPATCH: $KVERPATCH"
echo "KVER_MAJORMINOR: $KVER_MAJORMINOR"
echo "KVER_MAJOR: $KVER_MAJOR"
echo "KVER_MINOR: $KVER_MINOR"
echo "KVER_PATCHNO: $KVER_PATCHNO"

}

#
# Figure out kernel version
# Return the version string in KVER (e.g. 2.2.6)
#
get_kver()
{
    check_kver
#    echo "inside get_kver()"
    get_vers_h $KSRC/include/linux/version.h
#
#  SuSE started shipping 2 direstory paths for Linux source on a maintenance release
#  NOTE NOT A SERVICE PACK RELEASE.... so the following was added to check
#  all paths
#
    if [ ! -n "$KVER_H" ]; then
       get_vers_h $KBIN/include/linux/version.h
    fi
    if [ -n "$OPT_VERSIONLINUX" ]; then
	KVER=$OPT_VERSIONLINUX
    fi
    if [ -n "$KVER" ]; then
	$(test "$KVER" = "$(uname -r)") && USE_RUNNING_KERNEL=y
    fi
    if [ "$USE_RUNNING_KERNEL..." = "y..." ]; then
	KVER=`uname -r`
    elif [ -n "$KSRC" ]; then
	if [ -f $KSRC/include/linux/version.h ]; then
	    KVER=$KVER_H
	elif [ -f $KBIN/include/linux/version.h ]; then
	    KVER=$KVER_H
        elif [ -f $KBIN/include/generated/uapi/linux/version.h ]; then
	    KVER=$KBIN/include/generated/uapi/linux/version.h
	elif [ -f $KSRC/vmlinux ]; then
	    KVDEC=`nm -g $KSRC/vmlinux | grep Version_ | sed -e 's/^.*_//'`
	    KMAJ=`expr $KVDEC / 65536`
	    KMIN=`expr $KVDEC / 256`
	    KMIN=`expr $KMIN % 256`
	    KPCH=`expr $KVDEC % 256`
	    KVER="$KMAJ.$KMIN.$KPCH"
	elif grep -q "Red Hat" /etc/issue && rh_get_system_map; then
	    KVDEC=`grep Version_ $SMAP | sed -e 's/^.*_//'`
	    KMAJ=`expr $KVDEC / 65536`
	    KMIN=`expr $KVDEC / 256`
	    KMIN=`expr $KMIN % 256`
	    KPCH=`expr $KVDEC % 256`
	    KVER="$KMAJ.$KMIN.$KPCH"
	else
	    echo "The file $KSRC/include/linux/version.h is not present."
	    echo "LiS installation cannot proceed without it.  Please fix"
	    echo "this problem and then try the installation again."
	    exit 1
	fi
    else
	KVER=`uname -r`
    fi
    # Remove the extra version glarf from the end of kernel version
    NKVER=`echo $KVER | sed -e 's/-.*//'`
    parse_kver $KVER
}


#
# Having dug out the kernel version from the kernel source info, now
# verify that the currently running kernel has the same settings.
#
kver_h_err_msg()
{
    echo
    echo "Your kernel source is for kernel version $KVER_H, but"
    echo "your running kernel is version $PKVER.  Installation"
    echo "will proceed by may encounter problems later."
    echo
    do_confirm
}

verify_kver()
{
    if [ ! -f /proc/sys/kernel/osrelease ]; then
	echo
	echo "The kernel version cannot be verified because there"
	echo "is no /proc/sys/kernel/osrelease present on the system."
	echo "Chances are that you will experience some kind of problem in"
	echo "loading or running LiS.  This problem really should"
	echo "be rectified before continuing with the installation."
	echo
	do_confirm
	return
    fi

    PKVER=`cat /proc/sys/kernel/osrelease`
    NPKVER=`echo $PKVER | sed -e 's/-.*//'`
    if [ "$NKVER" != "$NPKVER" ]; then
	echo
	echo "Your kernel source is for kernel version $NKVER, but"
	echo "your running kernel is version $NPKVER.  This is a"
	echo "good indication that you are not running on the kernel"
	echo "represented by the kernel source.  Please make the"
	echo "running kernel the same as the one in kernel source and"
	echo "then install LiS again."
	echo
	do_confirm
	exit 1
    fi

    if [ "$KVER_H..." = "..." ]; then
	echo
	echo "The file $KSRC/include/linux/version.h is missing"
        echo "and file $KBIN/include/linux/version.h is missing"
	echo "LiS needs thie file in order to build properly."
	echo "This may be an indication that there is no kernel"
	echo "source on this machine, or only partial kernel source."
	echo
	do_confirm
	exit 1
    fi

    if [ "$NKVER_H..." != "$NPKVER..." ]; then
	echo
	echo "Your kernel source is for kernel version $NKVER_H, but"
	echo "your running kernel is version $NPKVER.  This is a"
	echo "good indication that you are not running on the kernel"
	echo "represented by the kernel source.  Please make the"
	echo "running kernel the same as the one in kernel source and"
	echo "then install LiS again."
	echo
	do_confirm
	exit 1
    fi

    if [ "$KVER_H..." != "$PKVER..." ]; then
	if [ -f /boot/vmlinuz.version.h ]; then
	    OKVER_H=$KVER_H
	    get_vers_h /boot/vmlinuz.version.h
	    if [ "$KVER_H..." = "$PKVER..." ]; then
		echo
		echo "Your kernel source is for kernel version $OKVER_H, but"
		echo "your running kernel is version $PKVER.  However,"
		echo "the file /boot/vmlinuz.version.h has the correct"
		echo "information it it.  Installation will proceed by"
		echo "copying this file to $KSRC/include/linux/version.h."
		echo
		do_confirm
		if [ ! -f $KSRC/include/linux/version.h.orig ]; then
		    mv  $KSRC/include/linux/version.h \
			$KSRC/include/linux/version.h.orig
		fi
		cp -f /boot/vmlinuz.version.h $KSRC/include/linux/version.h
	    else
		kver_h_err_msg
	    fi
	else
	    kver_h_err_msg
	fi
    else
	echo "Kernel version verified between kernel source and running kernel"
    fi
}

#
# Red Hat helper for getting SMP info
#
# Return 0 (true) if found, 1 (false) if not
#
rh_get_smp()
{
    if ! grep -q "Red Hat" /etc/issue || ! rh_get_system_map; then
	return 1
    fi

    if grep -w -q $SMP_GREP_ID $SMAP; then
	NEED_KSMP=0
	KSMP=y			# SMP kernel
    else
	KSMP=			# non-SMP kernel
    fi
    return 0			# got info
}

#
# Get SMP or not
# Return result in KSMP
#
get_smp()
{
#    echo "inside get_smp()"
#    echo "KVER_MAJORMINOR is $KVER_MAJORMINOR"

    if [ "$KVER_MAJORMINOR" = "2.4" ]; then
      SMP_GREP_ID='smp_num_cpus'
    elif [ "$KVER_MAJORMINOR" = "2.6" ]; then
      SMP_GREP_ID='smp_cpus_done'
    elif [ ${KVER_MAJOR} -ge 3  ]; then
      SMP_GREP_ID='smp_cpus_done'
    fi

    NEED_KSMP=0				# default is "found"
    if [ "$USE_RUNNING_KERNEL..." = "y..." ]; then
	if grep -q $SMP_GREP_ID $KSYMS; then
	    KSMP=y
	else
	    KSMP=
	fi
    else
	KSMP=`ac_get_config CONFIG_SMP`	# check autoconf.h
	if [ $? -eq 0 ]; then		# found
	    : OK
	elif [ -f $KSRC/vmlinux ]; then	# compiled kernel?
	    if nm -g $KSRC/vmlinux |grep -w -q $SMP_GREP_ID; then
		KSMP=y			# SMP kernel
	    else
		KSMP=			# non-SMP kernel
	    fi
	elif [ -f $KSRC/.config ]; then	# kernel .config file?
	    KSMP=`dc_get_config "CONFIG_SMP=y"`
	else
	    NEED_KSMP=1			# still need the option
	fi
    fi

    if [ "$KSMP..." = "y..." ]; then
	$qecho "Kernel support for SMP detected."
    else
	$qecho "No kernel support for SMP detected."
    fi
}

#
# Helper routine for Red Hat systems.  This is invoked when there
# is no vmlinux available.  If the system is Red Hat we look at the
# System.map file in /boot for some of our information.
#
# Return 0 (true) if found, 1 (false) if not
#
rh_get_modules()
{
    if ! grep -q "Red Hat" /etc/issue || ! rh_get_system_map; then
	return 1
    fi

    if grep -q init_modules $SMAP; then
	NEED_KMODULES=0
	KMODULES=y			# Module support
	if grep -q unregister_chrdev_R $KSYMS; then
	    KMODVERS=y
	else
	    KMODVERS=
	fi
    else
	KMODULES=			# No module support
    fi
    return 0
}

#
# Get Modules or not
# Return result in KMODULES
#
get_modules()
{
    NEED_KMODULES=0				# default is "found"
    if [ "$USE_RUNNING_KERNEL..." = "y..." ]; then
	KMODULES=y
	if [ "$KVER_MAJORMINOR" = "2.6" ]; then
	    KMODVERS=`ac_get_config CONFIG_MODVERSIONS`
        elif [ ${KVER_MAJOR} -ge 3  ]; then
            KMODVERS=`ac_get_config CONFIG_MODVERSIONS`
	elif grep -q schedule_R $KSYMS; then
	    KMODVERS=y
	else
	    KMODVERS=
	fi

    else
	KMODULES=`ac_get_config CONFIG_MODULES`	# check autoconf.h
	if [ $? -eq 0 ]; then		# found
	    KMODVERS=`ac_get_config CONFIG_MODVERSIONS`
	elif [ -f $KSRC/vmlinux ]; then	# compiled kernel?
	    if nm -g $KSRC/vmlinux |grep -w -q init_modules; then
		KMODULES=y			# module support
		if strings $KSRC/vmlinux |grep -q Using_Versions; then
		    KMODVERS=y
		else
		    KMODVERS=
		fi
	    else
		KMODULES=			# non-module support
	    fi
	elif [ -f $KSRC/.config ]; then	# kernel .config file?
	    KMODULES=`dc_get_config "CONFIG_MODULES=y"`
	    if [ "$KMODULES..." = "y..." ]; then
		KMODVERS=`dc_get_config "CONFIG_MODVERSIONS=y"`
	    fi
	else
	    NEED_KMODULES=1			# still need the option
	fi
    fi

    if [ "$KMODVERS..." = "y..." ]; then
	if [ "$KVER_MAJORMINOR" = "2.6" ]; then
	    echo '/* Configure generated dummy file for 2.6 */' \
	    		>${SRCDIR}/include/sys/modversions.h
	    LISMODVERS=y
        elif [ "$KVER_MAJOR" = "3" ]; then
            echo '/* Configure generated dummy file for 3.0 */' \
                        >${SRCDIR}/include/sys/modversions.h
           LISMODVERS=y 
        elif [ $KVER_MAJOR -ge 4 ]; then
            echo '/* Configure generated dummy file for 4.0 or greater */' \
                        >${SRCDIR}/include/sys/modversions.h
           LISMODVERS=y
	fi
	$qecho "Kernel support for mod-versions detected."
    else
	$qecho "No kernel support for mod-versions detected."
    fi
}

#
# Get the IPV6 configuration option from kernel
#
get_ipv6()
{
    if [ "$USE_RUNNING_KERNEL..." = "y..." ]; then
	if grep -q ipv6_addr_type $KSYMS; then
	    IPV6=y
	else
	    IPV6=
	fi
    else
	IPV6=`ac_get_config CONFIG_IPV6`	# check autoconf.h
	if [ $? -eq 0 ]; then		# found
	    : OK
	elif [ -f $KSRC/vmlinux ]; then	# compiled kernel?
	    if nm -g $KSRC/vmlinux |grep -w -q ipv6_addr_type; then
		IPV6=y			# SMP kernel
	    else
		IPV6=			# non-SMP kernel
	    fi
	elif [ -f $KSRC/.config ]; then	# kernel .config file?
	    IPV6=`dc_get_config "CONFIG_IPV6=y"`
	else
	    IPV6=
	    echo "Cannot determine if kernel supports IPV6, assume not."
	fi
    fi

    if [ "$IPV6..." = "y..." ]; then
	$qecho "Kernel support for IP version 6 detected."
    else
	$qecho "No kernel support for IP version 6 detected."
    fi
}

get_ipv6_module()
{
    if [ "$USE_RUNNING_KERNEL..." = "y..." ]; then
	if grep -q tcp_openreq_cachep $KSYMS; then
	    IPV6_MODULE=y
	else
	    IPV6_MODULE=
	fi
    else
	IPV6_MODULE=`ac_get_config CONFIG_IPV6_MODULE`	# check autoconf.h
	if [ $? -eq 0 ]; then		# found
	    : OK
	elif [ -f $KSRC/vmlinux ]; then	# compiled kernel?
	    if nm -g $KSRC/vmlinux |grep -w -q tcp_openreq_cachep; then
		IPV6_MODULE=y			# SMP kernel
	    else
		IPV6_MODULE=			# non-SMP kernel
	    fi
	elif [ -f $KSRC/.config ]; then	# kernel .config file?
	    IPV6_MODULE=`dc_get_config "CONFIG_IPV6_MODULE=y"`
	else
	    IPV6_MODULE=
	    echo "Cannot determine if kernel supports IPV6_MODULE, assume not."
	fi
    fi

    if [ "$IPV6_MODULE..." = "y..." ]; then
	$qecho "Kernel support for IP version 6 modules detected."
    else
	$qecho "No kernel support for IP version 6 modules detected."
    fi
}

#
# Figure out whether we should be compiled with -mregparm=n for register
# passing of arguments.
#
get_regparm()
{
    CCREGPARM=
    if [ "$TARGET" = "l" ]; then
	if [ -f $KSRC/drivers/base/firmware_class.ko ] && \
	     strings $KSRC/drivers/base/firmware_class.ko | grep vermagic | \
	     grep REGPARM
	then
	    CCREGPARM="-mregparm=3"
	elif [ -f $KSRC/include/linux/autoconf.h  -o \
	       -f $KSRC/include/generated/autoconf.h ]; then
	    regparm_defined=`ac_get_config CONFIG_REGPARM`
	    if [ "$regparm_defined..." = "y..." ]; then
		CCREGPARM="-mregparm=3"
            elif [ -f $KSRC/arch/x86/Makefile_32 ] && \
		[ "$MACHINE" = "i686" ] && \
		grep regparm $KSRC/arch/x86/Makefile_32; then
			CCREGPARM="-mregparm=3"
            elif [ -f $KSRC/arch/x86/Makefile ] && \
                 [ "$MACHINE" = "i686" ] && \
                 grep regparm $KSRC/arch/x86/Makefile; then
                        CCREGPARM="-mregparm=3"
            elif [ -f $KSRC/arch/i386/Makefile ] && \
                 [ "$MACHINE" = "i686" ] && \
                 grep regparm $KSRC/arch/i386/Makefile; then
		        CCREGPARM="-mregparm=3"
            else
 	  		CCREGPARM="-Dccregparm=0"
 	    fi
	else
	    CCREGPARM="-Dccregparm=0"
	fi
	if [ "$CCREGPARM" = "-mregparm=3" ]; then
	    echo "Kernel compiled using register passing for parameters"
	else
	    echo "Kernel compiled using stack passing for parameters"
	fi
    elif [ "$TARGET" = "u" ]; then
	CCREGPARM="-Dccregparm=0"
    fi
    export CCREGPARM
}


#
# From /proc/ksyms, generate a C header file with defines for all
# of the version-mangled symbol names.
#
generate_symbol_names()
{
    grep _R $KSYMS | sed -e 's/^.........//' -e 's/[ 	].*//' |
    	sed 's/\(.*\)_R\(.*\)/#define \1 \1_R\2/'
}

#
# From what LiS has gleaned from /proc, generate a little autoconf.h
# file that has the correct settings for MODULES, MODVERSIONS and SMP.
#
generate_autoconf()
{
    acf="include/sys/autoconf.h"
    echo '/* THIS FILE WAS GENERATED.  MANUAL CHANGES MAY BE LOST. */' >$acf

    if [ "$KSMP" = "y" ]; then
	echo "#define CONFIG_SMP 1" >>$acf
    else
	echo "#undef CONFIG_SMP" >>$acf
    fi
    if [ "$KMODULES" = "y" ]; then
	echo "#define CONFIG_MODULES 1" >>$acf
    else
	echo "#undef CONFIG_MODULES" >>$acf
    fi
    if [ "$KMODVERS" = "y" ]; then
	echo "#define CONFIG_MODVERSIONS 1" >>$acf
    else
	echo "#undef CONFIG_MODVERSIONS" >>$acf
    fi
    LISAUTOCONF=y
}

#
# get_empty_inode_option
#
# Try to find out whether or not the routine that gets an empty inode
# is still called "get_empty_inode" or "new_inode".
#
# we assume this option will be passed a value s; this makes it easier
# to define the macro conventionally
#
# This must be done after it is known whether we are going to install
# on the running kernel and whether there is kernel source available.
#
get_empty_inode_option()
{
    if [ "$TARGET" != "l" ]; then
	return				# not relevant unless Linux kernel
    fi

    if [ "$KVER_MAJORMINOR" = "2.6" ]; then
       GET_EMPTY_INODE="new_inode((LIS_SB))"
    elif [ "$KVER_MAJOR" = "3" ]; then
       GET_EMPTY_INODE="new_inode((LIS_SB))"
    elif [ $KVER_MAJOR -ge 4 ]; then
       GET_EMPTY_INODE="new_inode((LIS_SB))"
    elif [ "$USE_RUNNING_KERNEL..." = "y..." ]; then
	if grep -q new_inode $KSYMS; then
	    GET_EMPTY_INODE="new_inode((LIS_SB))"
	elif grep -q get_empty_inode $KSYMS; then
	    GET_EMPTY_INODE="get_empty_inode()"
	else
	    GET_EMPTY_INODE="get_empty_inode()"
	    echo "Your running kernel exports neither the symbol"
	    echo "get_empty_inode nor new_inode.  The compilation of"
	    echo "LiS will probably print warnings related to"
	    echo "these symbols, and LiS will probably fail to"
	    echo "load as a module."
	    do_confirm
	fi
	return
    elif [ -f $KSRC/kernel/ksyms.c ]; then
	if grep -q new_inode $KSRC/kernel/ksyms.c; then
	    GET_EMPTY_INODE="new_inode((LIS_SB))"
	elif grep -q get_empty_inode $KSRC/kernel/ksyms.c; then
	    GET_EMPTY_INODE="get_empty_inode()"
	else
	    GET_EMPTY_INODE="get_empty_inode()"
	    echo "Your kernel source exports neither the symbol"
	    echo "get_empty_inode nor new_inode.  The compilation of"
	    echo "LiS will probably print warnings related to"
	    echo "these symbols, and LiS will probably fail to"
	    echo "load as a module."
	     if [ "$OPT_FORCENEWINODE..." = "..." ] ;then
	      do_confirm
             else
                 if  [ "$OPT_FORCENEWINODE" = "y" ] ;then
             	    GET_EMPTY_INODE="new_inode((LIS_SB))" 
                    #echo "***new_inode FORCED***"
		    NEW_INODE_FORCED=" (forced)"
                else
           	    GET_EMPTY_INODE="get_empty_inode()" 
                fi
             fi
	fi
	return
    else
	GET_EMPTY_INODE="get_empty_inode()"
	echo "You have told the LiS installation that you do not"
	echo "intend to run LiS on the running kernel and we cannot"
	echo "find the file $KSRC/kernel/ksyms.c"
	echo "One or the other is necessary to determine whether"
	echo "to use get_empty_inode or new_inode.  The compilation of"
	echo "LiS will probably print warnings related to"
	echo "these symbols, and LiS will probably fail to"
	echo "load as a module."
        if [ "$OPT_FORCENEWINODE..." = "..." ] ;then
            do_confirm
        else
            if  [ "$OPT_FORCENEWINODE" = "y" ] ;then
                GET_EMPTY_INODE="new_inode((LIS_SB))" 
                #echo "***new_inode FORCED***"
		NEW_INODE_FORCED=" (forced)"
            else
                GET_EMPTY_INODE="get_empty_inode()" 
            fi
        fi
    fi

    $qecho "GET_EMPTY_INODE=${GET_EMPTY_INODE}${NEW_INODE_FORCED}"
}

set_cpus_allowed_option()
{
    if [ "$TARGET" != "l" ]; then
	return				# not relevant unless Linux kernel
    fi

    SCHED_H=$KSRC/include/linux/sched.h
    if grep -q set_cpus_allowed $SCHED_H; then
	SET_CPUS_ALLOWED=y
    else
	SET_CPUS_ALLOWED=n
    fi
}

#
# check the compiler version used to compile the kernel against
# the version info of various C compilers that are available.
#
C_compiler_version()
{
    if [ ! -x /usr/bin/$1 ]; then
	return 1
    fi

    CC_VERS=`/usr/bin/$1 -v 2>&1 | \
    	    grep 'gcc version' | \
	    sed -e 's/^.*gcc version // ' -e 's/ .*//' -e 's/^.*-//'`

    echo $CC_VERS
}

kernel_cc_version()
{
    V=`cat /proc/version | \
    	    grep 'gcc version' | \
	    sed -e 's/^.*gcc version // ' -e 's/ .*//' -e 's/^.*-//'`
    echo $V
}

pick_a_c_compiler()
{
    KERN_CC_VERS=`kernel_cc_version`
    if [ "$KERN_CC_VERS..." = "..." ]; then
	return 1
    fi

    CC_VERS=`C_compiler_version kgcc`
    if [ "$CC_VERS..." = "$KERN_CC_VERS..." ]; then
	echo kgcc
	return 0
    fi

    CC_VERS=`C_compiler_version gcc`
    if [ "$CC_VERS..." = "$KERN_CC_VERS..." ]; then
	echo gcc
	return 0
    fi

    CC_VERS=`C_compiler_version gcc3`
    if [ "$CC_VERS..." = "$KERN_CC_VERS..." ]; then
	echo gcc3
	return 0
    fi

    CC_VERS=`C_compiler_version cc`
    if [ "$CC_VERS..." = "$KERN_CC_VERS..." ]; then
	echo cc
	return 0
    fi

    return 1
}

# the 'kbuild' build process originated with 2.5.x kernels.  Prior to
# 2.6.6, it required '-DKBUILD_MODNAME=...' for modules.  As of 2.6.6,
# that is no longer necessary, but kernel exported symbols must be
# passed into kbuild.  We define these conditions via the following
# function
#
check_kbuild()
{
    if [ "$TARGET" != "l" ]; then
	return
    fi
    if [ ${KVER_MAJOR} -ge 3  ]; then
       KBUILD=y
       KBUILD_NEEDS_SYMVERS=y
       KBUILD_NEEDS_MODNAME=y
       MODULE_INIT_TOOLS=y
       if ls $KSRC/modversions-* >/dev/null 2>/dev/null; then
           KSYMVERS=`ls -rt $KSRC/modversions-* 2>/dev/null | tail -1`
       else                    # define it whether present or not
           KSYMVERS=$KSRC/Module.symvers
           if [ ! -e $KSYMVERS ]; then  # if Module.symvers not there, get it
              cp -p $KBIN/Module.symvers $KSRC
           fi
       fi
    
       KBUILD_STR="-D\"KBUILD_STR(s)=s\""
       grep KBUILD_STR $KSRC/scripts/Makefile.lib > /dev/null && \
                KBUILD_STR="-D\"KBUILD_STR(s)=\#s\""
       return
    fi

    [ ${KVER_MAJOR} -eq 2 -a ${KVER_MINOR} -ge 5 ] && KBUILD=y || KBUILD=n

    [ "${KBUILD}" = "y" -a ${KVER_MINOR} -eq 6 -a ${KVER_PATCHNO} -ge 4 ] && \
	KBUILD_NEEDS_SYMVERS=y || :

    [ "${KBUILD}" = "y" -a ! "${KBUILD_NEEDS_SYMVERS}" = "y" ] && \
	KBUILD_NEEDS_MODNAME=y || :

    [ "${KBUILD}" = "y" ] && MODULE_INIT_TOOLS=y || MODUTILS=y

    if [ "$KBUILD_NEEDS_SYMVERS" = "y" ]; then
	if ls $KSRC/modversions-* >/dev/null 2>/dev/null; then
	    KSYMVERS=`ls -rt $KSRC/modversions-* 2>/dev/null | tail -1`
	else			# define it whether present or not
	    KSYMVERS=$KSRC/Module.symvers
            if [ ! -e $KSYMVERS ]; then  # if Module.symvers not there, get it
               cp -p $KBIN/Module.symvers $KSRC
            fi
	fi
    fi

    KBUILD_STR="-D\"KBUILD_STR(s)=s\""
    if [ "${KBUILD}" = "y" ]; then
	grep KBUILD_STR $KSRC/scripts/Makefile.lib > /dev/null && \
		KBUILD_STR="-D\"KBUILD_STR(s)=\#s\""
    fi
}

#=========================================================================

$qecho "LiS Configure script version $Configure_version" "$COMMENT"
$qecho

# if not set, set SRCDIR to directory where this script lives.  Get the
# actual directory name, not a symlink.
#
SRCDIR=$(cd ${SRCDIR:-$(dirname $0)}; pwd -P)
if [ -L $SRCDIR ]; then
    SRCDIR=`ls -ld $SRCDIR | sed -e 's/^.* //'`
fi

# set CONFIG to an absolute path name; if prefixed with ./, prefix with
# pwd; otherwise if relative (no leading /), prefix with SRCDIR
#
_config=$(echo -n $CONFIG | sed 's:^\./::')
if [ "$_config" != "$CONFIG" ]; then
	CONFIG=$(pwd)/${_config}
fi
unset _config
if [ "$(echo -n $CONFIG | sed 's:^/::')" = "$CONFIG" ]; then
	CONFIG=${SRCDIR}/${CONFIG}
fi

# function to convert '//' -> '/' and strip trailing '/'
#
cleanup_dir()
{
    sed -e "s:\/\/:/:g" | sed -e "s:\/$::"
}

# set directory defaults
#
package=`echo ${package:-LiS} | cleanup_dir`
prefix=`echo ${prefix:-/usr} | cleanup_dir`
execprefix=`echo ${execprefix:-${prefix}} | cleanup_dir`
includedir=`echo ${includedir:-${prefix}/include} | cleanup_dir`
libdir=`echo ${libdir:-${prefix}/lib} | cleanup_dir`
bindir=`echo ${bindir:-${execprefix}/bin} | cleanup_dir`
sbindir=`echo ${sbindir:-${execprefix}/sbin} | cleanup_dir`
sysconfdir=`echo ${sysconfdir:-/etc} | cleanup_dir`
datadir=`echo ${datdir:-${prefix}/share} | cleanup_dir`
pkgincludedir=`echo ${pkgincludedir:-${includedir}/${package}} | cleanup_dir`
pkglibdir=`echo ${pkglibdir:-${libdir}/${package}} | cleanup_dir`
pkgdatadir=`echo ${pkgdatadir:-${datadir}/${package}} | cleanup_dir`
pkgsrcdir=`echo ${pkgsrcdir:-${prefix}/src/${package}} | cleanup_dir`
mandir=`echo ${mandir:-${datadir}/man} | cleanup_dir`
modsubdir=`echo ${modsubdir:-misc} | cleanup_dir`

# uncomment the following line to see what OPT_ variables are set
#set | grep '^OPT_' | $qcat
$qecho "CONFIG=$CONFIG"
$qecho
$qecho "package=${package}"
$qecho "prefix=${prefix}"
$qecho "execprefix=${execprefix}"
$qecho "includedir=${includedir}"
$qecho "libdir=${libdir}"
$qecho "bindir=${bindir}"
$qecho "sbindir=${sbindir}"
$qecho "sysconfdir=${sysconfdir}"
$qecho "datadir=${datadir}"
$qecho "pkgincludedir=${pkgincludedir}"
$qecho "pkglibdir=${pkglibdir}" 
$qecho "pkgdatadir=${pkgdatadir}"
$qecho "pkgsrcdir=${pkgsrcdir}"
$qecho "mandir=${mandir}"
$qecho "modsubdir=${modsubdir}"
$qecho

#
# Establish defaults
#

if [ -f $CONFIG ]; then
. $CONFIG
else
    USING_DEFAULTS=y
    USE_RUNNING_KERNEL=y
    CROSS_COMPILING=n
    TARGET=l
    CONFIG_STREAMS=m
    MOD_INSTALL=y
    default_ksrc
    check_ksrc
    CONFIG_MK_KERNEL=n
    STRMS_QUEUES=t
    DBG_OPT=D
    LIS_SHLIB=y
    MACHINE=`uname -m`
    INT_PSW=y
    STREAMS_REGPARM=${STREAMS_REGPARM:-0}
fi
unset CONFIG_DEV
USE_KMEM_CACHE=y
USE_KMEM_TIMER=y

if [ "$MACHINE" = "s390x" ]; then
  INT_PSW=n
fi
if [ "$MACHINE" = "ppc64le" ]; then
  INT_PSW=n
fi
if [ "$MACHINE" = "x86_64" ]; then
  INT_PSW=n
fi

#
# TARGET
#
PROMPT="\
How do you want to configure STREAMS?\n\
    l = to run in the Linux kernel\n\
    u = to run in user level\n\
    q = to run under QNX (may not work)\n\
Please enter your choice"
RESPONSE="l u q"
DEFAULT="$TARGET"
ARGVVALUE="$OPT_LEVELRUN"
do_read_choice
TARGET=$RESULT

if [ "$TARGET" = "l" ]; then
    #
    # The linux target needs some special handling
    #
    PROMPT="\
Are you using the native Linux C compiler (y) or\n\
are you cross-compiling using a different compiler (n)?\n\
Native C (y) or cross-compile (n)?"
        RESPONSE="y n"
        ARGVVALUE=$OPT_NATIVECOMPILER
	if [ $CROSS_COMPILING = "y" ]; then
	    DEFAULT=n
	else
	    DEFAULT=y
	fi
        do_read_choice
        case $RESULT in
	    y)
		    CROSS_COMPILING=n
		    ;;
	    n)
		    CROSS_COMPILING=y
		    echo
		    echo "You should create a file named \"cross-compile\""
		    echo "which contains \"make\" assignments for the name"
		    echo "of your cross compiler.  See the file config.mk"
		    echo "for more information on this."
		    echo
		    do_confirm
		    ;;
        esac

    #
    # See if the GNU Libc stropts.h is an old version.  If so, substitute
    # the new 2.2 version.
    #
    if grep -w -q RDNORM /usr/include/sys/bits/stropts.h 2>/dev/null; then
	mv /usr/include/sys/bits/stropts.h /usr/include/sys/bits/stropts.h.orig
	cp -f ./include/sys/gnu.stropts.h /usr/include/sys/bits/stropts.h
	echo "Updated version of stropts.h installed in /usr/include/sys/bits"
    fi

    #
    # Verify kernel version, SMP and mod versions against the running
    # kernel if the user says that he/she intends to install on the
    # running kernel.
    #
    PROMPT="\
Do you intend to run LiS on this machine with\n\
the currently running kernel?"
    RESPONSE="y n"
    ARGVVALUE=${OPT_ONRUNNINGLNX}
    if [ "$USE_RUNNING_KERNEL..." = "..." ]; then
        DEFAULT="n"
    else
        DEFAULT="y"
    fi
    do_read_choice
    case $RESULT in
	y) USE_RUNNING_KERNEL=y ;;
	n) USE_RUNNING_KERNEL= ;;
    esac

    #
    # Kernel source location
    #
    if [ "$USE_RUNNING_KERNEL..." = "..." ]; then
	PROMPT="Enter directory location of your kernel source\n          "
	DEFAULT=$KSRC
	if [ "$KSRC..." = "..." ]; then
	    DEFAULT="/lib/modules/`uname -r`/build"
	fi
	if [ ! -d "$KSRC" ]; then
	    DEFAULT="/usr/src/linux"
	    check_ksrc
	fi
        ARGVVALUE=${OPT_KSOURCEDIR}
	if do_read_dir; then
	    KSRC=$RESULT
	    NOKSRC=0
	    KINCL=$KSRC/include
	else
	    echo "Cannot locate kernel source."
	    echo "Will use /usr/include for header files."
	    KSRC=/usr
	    KINCL=$KSRC/include
	    NOKSRC=1
	fi
    else
	NOKSRC=0
	if [ -d $KSRC ]; then
	    : Retain default setting
	    KINCL=$KSRC/include
	elif [ -d /usr/src/linux ]; then
	    KSRC=/usr/src/linux
	    KINCL=$KSRC/include
	else
	    echo
	    echo "No apparent kernel source directory.  LiS compilation"
	    echo "may very well fail.  If this should happen, load your"
	    echo "kernel source, or reinstall your kernel with source"
	    echo "and install LiS again."
	    echo
	    do_confirm
	    KSRC=/usr
	    KINCL=$KSRC/include
	    NOKSRC=1		# act as though no kernel source
	fi
	echo "Will use $KSRC/include for header files."
    fi
    #
    # Include arch include files
    #
    KARCH=`readlink $KSRC/include/asm|cut -d '-' -f2`
    KARCHINCL=$KSRC/arch/$KARCH/include
    #
    # Try to dig some info out of the kernel binary "vmlinux".  If we
    # can find out this stuff from the binary then we don't need the
    # .config file
    #
    get_kver
    get_smp
    get_modules    
    #
    # If the asm path does not exist, must be SuSE, check include2 path
    #  
    if [ ! -e $KARCHINCL/asm ]; then
         if [ -e $KSRC/arch/powerpc/ ] && [ "$MACHINE" = "ppc64le" ]; then
             KARCHINCL=$KSRC/arch/powerpc/include
         else
             KARCHINCL=$KBIN/include
         fi
    fi
    if [ -e $KBIN/include2 ]; then
       KARCHINCL2=$KBIN/include2
    elif [ -e $KSRC/arch/x86/ ] && [ "$MACHINE" = "i686" ]; then
       KARCHINCL2=$KSRC/arch/x86/include
    elif [ -e $KSRC/arch/x86/ ] && [ "$MACHINE" = "x86_64" ]; then
       if [ $KVER_MAJOR -ge 4 ]; then
            KARCHINCL2=$KSRC/arch/x86/include
            KARCHINCL=$KSRC/arch/include
	    KINCL=$KSRC/include
       else
            KARCHINCL2=$KSRC/arch/x86/include
       fi	    
    elif [ -e $KSRC/arch/s390/ ] && [ "$MACHINE" = "s390x" ]; then
       KARCHINCL2=$KSRC/arch/s390/include 
    elif [ -e $KSRC/arch/powerpc/ ] && [ "$MACHINE" = "ppc64le" ]; then
       KARCHINCL2=$KSRC/arch/powerpc/include 
    fi
    #  For 3.10 kernels and later, check for uapi directory
    if [ -e $KARCHINCL2/uapi ]; then
       if [ -e $KSRC/arch/s390/ ] && [ "$MACHINE" = "s390x" ]; then
          KARCHINCL=$KSRC/arch/s390/include
	  if [ $KVER_MAJOR -ge 5 ]; then
              KARCHINCL2=$KSRC/include/uapi
          fi
       elif [ -e $KSRC/arch/x86/ ] && [ "$MACHINE" = "x86_64" ]; then
          KARCHINCL=$KSRC/arch/x86/include
       elif [ -e $KSRC/arch/powerpc/ ] && [ "$MACHINE" = "ppc64le" ]; then
          KARCHINCL=$KSRC/arch/powerpc/include
       fi
    fi
#    If Kernel is less than 4.0, user uapi, else use generated
    if [ $KVER_MAJOR -ge 4 ]; then  # for any > 4 
       if [ $KVER_MINOR -gt 4 ] || [ $KVER_MAJOR -ge 5 ]; then
          if [ "$MACHINE" = "s390x" ]; then
              KARCHINCL3=$KSRC/arch/s390/include/uapi/asm
              KARCHINCL4=$KSRC/arch/s390/include/generated
          elif [ "$MACHINE" = "x86_64" ]; then
              if [ $KVER_MAJOR -ge 5 ]; then     
                 KARCHINCL3=$KSRC/arch/x86/include/uapi/asm
              else 		  
                 KARCHINCL3=$KSRC/arch/x86/include/uapi/asm
	      fi
              if [ $KVER_MAJOR -ge 5 ]; then
                 KARCHINCL4=$KBIN/arch/x86/include/generated
              else
                 KARCHINCL4=$KBIN/arch/x86/include/generated
              fi
          elif [ "$MACHINE" = "ppc64le" ]; then
              KARCHINCL3=$KSRC/arch/powerpc/include/uapi
          fi
       fi
    fi		 
#    echo " KVER_MAJOR is $KVER_MAJOR and INCL2 is $KARCHINCL2  #2 "
#
    get_ipv6
    get_ipv6_module
    if [ "$USE_RUNNING_KERNEL..." = "y..." ]; then
	verify_kver
    fi
    get_regparm
    if [ $NEED_KSMP -eq 1 -o $NEED_KMODULES -eq 1 ]; then
	if [ "$USE_RUNNING_KERNEL..." = "y..." ]; then
	    echo "Could not figure out whether or not your running kernel"
	    echo "was compiled with SMP or MODULES set.  Installation aborted."
	    exit 1
	fi
	NEED_KCONFIG=1		# couldn't access kernel binary
    else
	NEED_KCONFIG=0		# have info from kernel binary
    fi

    #
    # See if the kernel's .config file is there.  If not then the user
    # has not done a "make menuconfig" yet.
    #
    if [ $NOKSRC -eq 0 -a $NEED_KCONFIG -eq 1 -a ! -f $KSRC/.config ]; then
        PROMPT="\
It appears that you have not done a 'make menuconfig' on\n\
your kernel in $KSRC yet.  You should do that now to avoid\n\
problems with the installation.\n\
Do you want to do that now?"
        RESPONSE="y n"
        ## This is purely an interactive choice.. CLI options will avoid it
        unset ARGVVALUE
        do_read_choice
        case $RESULT in
	    y)
		    if ! make -C $KSRC menuconfig; then
		        echo "Menuconfig failed.  LiS installation aborted."
		        exit 1
		    fi
		    echo "Make menuconfig was successful."
		    echo "Continuing with LiS installation."
		    ;;
	    n)
		    echo "OK, but this may cause problems with the installation."
		    ;;
        esac
    fi

    #
    # If we have a kernel configuration now, source it.
    #
    if [ $NEED_KCONFIG -eq 1 -a -f $KSRC/.config ]; then
        . $KSRC/.config
    fi

    #
    # See if version.h is there.  It may not be if the user just unpacked
    # a fresh version of Linux and has not done a "make dep" yet.
    #
    if [ $NEED_KCONFIG -eq 1 ]; then
	check_kver
    fi
    #
    # Now see if there is one present.
    #
    if [ $NEED_KCONFIG -eq 1 -a ! -f $KSRC/include/linux/version.h ]; then
        PROMPT="\
It appears that you have not done a 'make dep' on your kernel yet.\n\
You will have to do this to proceed.\n\
Do you want to do that now?"
        RESPONSE="y n"
        ## This is purely an interactive choice.. CLI options will avoid it
        unset ARGVVALUE
        do_read_choice
        case $RESULT in
	    y)
	        if ! make -C $KSRC dep; then
	            echo "Make dep failed.  LiS installation aborted."
	            exit 1
	        fi
	        echo "Make dep was successful."
		echo "Continuing with LiS installation."
	        ;;
	    n)
		echo "LiS installation cannot proceed until this is done."
		echo "Please fix the problem and then try again."
		exit 1
		;;
        esac
    fi

    #
    # Kernel version
    #
    if [ "$USE_RUNNING_KERNEL..." = "y..." ]; then
	echo "Running kernel is version $KVER"
    else
	DEFAULT=$KVER
	PROMPT="Which version of the kernel are you building for?"
        if [ "$OPT_VERSIONLINUX..." = "..." ]; then
	do_readstring
	KVER=$RESULT
        else
        KVER=${OPT_VERSIONLINUX}
        fi
    
	parse_kver $KVER
    fi
#    echo "KVER_MAJOR is $KVER_MAJOR, KVER_MINOR is $KVER_MINOR"
    if [ $KVER_MAJOR -lt 2 ]; then
       if [ $KVER_MAJOR -lt 3 -a $KVER_MINOR -lt 3 ]; then
          echo
          echo "LiS is no longer compatible with Linux 1.x/2.0/2.2 kernels."
          echo
          exit 1
       fi
    fi

    #
    # CONFIG_STREAMS
    #
    # If we have concluded that the kernel does not support modules
    # then we need to inform the user of what is going on.  It is
    # next to impossible for a kernel not to support modules these
    # days.
    #
    if [ "$KMODULES" != "y" ]; then
	echo
	echo "Analysis of your kernel configuration suggests that your kernel"
	echo "does not support loadable modules.  This is extremely rare and"
	echo "is likely a result of mis-analysis of the kernel configuration"
	echo "files.  Installation will proceed as if the kernel supports"
	echo "loadable modules."
	echo 
    fi

    CONFIG_STREAMS=m
    if [ "$KVER_MAJORMINOR" = "2.6" -a $KVER_PATCHNO -ge 27 ]; then
       KBUILD_NEEDS_MODNAME=y
    elif [ "$KVER_MAJORMINOR" = "3.0" ]; then
       KBUILD_NEEDS_MODNAME=y
    elif [ "$KVER_MAJOR" = "3" ]; then  # for any > 3.0 
       KBUILD_NEEDS_MODNAME=y
       KBUILD_NEEDS_SYMVERS=y
    elif [ $KVER_MAJOR -ge 4 ]; then  # for any > 4 
       KBUILD_NEEDS_MODNAME=y
       KBUILD_NEEDS_SYMVERS=y
    fi
    #
    # See if the user wants STREAMS kernel loadable modules installed for
    # easy running.  Leaving the module for later loading is what is
    # needed for cross compiling.
    #
    PROMPT="\
After building STREAMS, do you want kernel loadable modules installed?\n\
This allows you to load it by typing in \"insmod streams\".\n\
    y = install it for module loading\n\
    n = just leave modules for later \"make modules_install\"\n\
Please enter y or n "
    RESPONSE="y n"
    DEFAULT="$MOD_INSTALL"
    ARGVVALUE=${OPT_LOADMODULES}
    do_read_choice
    MOD_INSTALL=$RESULT

    if [ "$MOD_INSTALL" = "y" ]; then
        if [ `whoami` != "root" ]; then
            echo
            echo "You must be root in order to install kernel modules."
            echo
            exit 1
        fi
    fi

    #
    # MOD_INST_DIR
    #
    # The old logic here was deleted - creating non-temporary directories
    # is a job for make install targets; our job here is just to choose a
    # directory name.
    #
    PROMPT="Enter desired kernel module directory\n"
    PROMPT="$PROMPT              "
    DEFAULT=${MOD_INST_DIR:-/lib/modules/${KVER}/${modsubdir}}
    ARGVVALUE=${OPT_MODULESLOCATION:-${DEFAULT}}
    do_read_dir
    MOD_INST_DIR=`echo $RESULT | cleanup_dir`
    if [ ! -d $MOD_INST_DIR ]; then
	if ! mkdir -p $MOD_INST_DIR; then
	    echo "Configure aborting"
	    exit 1
	fi
    fi
    $qecho "Module installation directory will be $MOD_INST_DIR"

    #
    # STRMS_QUEUES
    #
    # Streams queues are always run as tasklets these days.
    #
    STRMS_QUEUES="t"

    if [ $NOKSRC -eq 1 -a "$KMODVERS..." = "y..." ]; then
	echo "Generating ${SRCDIR}/include/sys/modversions.h."
	rm -f include/sys/modversions.h
	generate_symbol_names > ${SRCDIR}/include/sys/modversions.h
	LISMODVERS=y
    fi


else # Not a Linux kernel target
    # These configuration items only make sense in the Linux kernel
    KSRC=
    KVER=
    CONFIG_MK_KERNEL=
    STRMS_QUEUES=
    MOD_INST_DIR=
    MOD_INSTALL=
    KSMP=
    KMODULES=
    CONFIG_STREAMS=
fi # Not a Linux kernel target

#
# LIS_OLD_CONSTS
#
if [ "$LIS_OLD_CONSTS..." = "..." ]; then
    LIS_OLD_CONSTS=n
fi
PROMPT="\
When you make STREAMS, do you want to use backward compatible constants\n\
in the file stropts.h?  If you answer No (the default) you will get\n\
constants that are compatible with UnixWare and Solaris, but which\n\
differ somewhat from previous versions of LiS.  If you answer Yes\n\
you will get constants that are compatible with previous versions of\n\
LiS but somewhat incompatible with UnixWare and Solaris.  If you\n\
intend to run application programs that were compiled with LiS-2.6\n\
or earlier then they have the old constants compiled into them and\n\
you should answer Yes to this question.\n\
    y = LiS backward compatible constants in stropts.h\n\
    n = UnixWare/Solaris compatible constants in stropts.h\n\
Please enter y or n"
RESPONSE="y n"
DEFAULT=$LIS_OLD_CONSTS
ARGVVALUE=${OPT_BACKCOMPAT}
do_read_choice
LIS_OLD_CONSTS=$RESULT
if [ "$LIS_OLD_CONSTS..." = "y..." ]; then
    echo
    echo "When you compile your application programs you must include"
    echo "-DUSE_OLD_CONSTS on the command line so that your program"
    echo "uses the same values as LiS is being compiled with.  If you"
    echo "have an application program that was compiled with LiS-2.6"
    echo "or earlier then it has the old constants built into it."
    echo "It is to be preferred to use the new UnixWare/Solaris"
    echo "compatible constants as soon as it is practicable for you."
    echo
    do_confirm
fi

#
# SOLARIS_STYLE_CMN_ERR
#
if [ "$SOLARIS_STYLE_CMN_ERR..." = "..." ]; then
    SOLARIS_STYLE_CMN_ERR=n
fi
PROMPT="\
When you make STREAMS, do you want to use Solaris style cmn_err?\n\
In Solaris the newline goes on the end of the message.  For SVR4\n\
style cmn_err the newline goes on the beginning.\n\
    y = Solaris style cmn_err\n\
    n = SVR4 style cmn_err\n\
Please enter y or n"
RESPONSE="n y"
DEFAULT=$SOLARIS_STYLE_CMN_ERR
ARGVVALUE=${OPT_SOLARISSTYLE}
do_read_choice
SOLARIS_STYLE_CMN_ERR=$RESULT

#
# DBG_OPT
#
# Defaults to y for user build and to n for others
#
if [ "$DBG_OPT" = "D" ]; then
    if [ "$TARGET" = "u" ]; then
	DBG_OPT=y
    else
	DBG_OPT=n
    fi
fi
PROMPT="\
When you make STREAMS, do you want to compile for source level debugging?\n\
This is most useful when STREAMS is linked into the kernel and the\n\
gdbstub patch is installed in the kernel for kernel source level debugging.\n\
    y = set up for source level debugging\n\
    n = no source level debugging\n\
Please enter y or n"
RESPONSE="y n"
DEFAULT=$DBG_OPT
ARGVVALUE=${OPT_SRCDBG}
do_read_choice
DBG_OPT=$RESULT


#
# LIS_SHLIB
#
if [ "$TARGET" = "l" ]; then
    PROMPT="\
Do you want to use shared libraries?
If you select static linking, you will get larger binaries that run by
themselves. If you select dynamic linking, the binaries will be smaller but
you will have to install the shared libraries in a directory that is in your
LD_LIBRARY_PATH environment variable.
    y = use dynamic linking with shared libraries\n\
    n = use static linking\n\
Please enter y or n"
    RESPONSE="y n"
    DEFAULT=$LIS_SHLIB
    ARGVVALUE=${OPT_SHAREDLIBS}
    do_read_choice
    LIS_SHLIB=$RESULT
else
    LIS_SHLIB=n
fi

#
# INT_PSW
#
if [ "$INT_PSW..." = "..." ]; then
    INT_PSW=y
fi
PROMPT="\
When you make STREAMS, do you want to use int type for CPU flags?\n\
Responding 'n' is more portable but may cause warnings when you\n\
compile your driver code.\n\
    y = int type for CPU flags\n\
    n = unsigned long type for CPU flags\n\
Please enter y or n"
RESPONSE="y n"
DEFAULT=$INT_PSW
ARGVVALUE=${OPT_INTCPUFLAGS}
do_read_choice
INT_PSW=$RESULT

#
# CONFIG_DEV    -  Compile LiS for development or production.
#		   We ask the user the question with the opposite sense
#                  and then invert the answer for our internal flag.
#
# USE_KMEM_CACHE - Use level 2 cache memory for LiS queue and mblk structs
#                  for performance.
#
if [ "$CONFIG_DEV..." = "..." ]; then
    unset CONFIG_DEV
fi
PROMPT="\
When you make STREAMS, do you want LiS to be compiled in production mode?\n\
In this mode LiS will not audit queue, msg pointer, and internal LiS\n\
queue structure sanity for every STREAMs function call.  It will also\n\
use faster kernel allocations for messages.\n\
Responding 'y' is more appropriate for production environments\n\
Responding 'n' is more appropriate for development environments\n\
with verified modules/drivers.\n\
    y = Production mode\n\
    n = Development mode\n\
Please enter y or n"
RESPONSE="y n"
if [ "$CONFIG_DEV..." = "y..." ]; then
    DEFAULT=n
else
    DEFAULT=y
fi
ARGVVALUE="${OPT_PRODUCTIONCODE}"
do_read_choice
if [ "$RESULT..." = "y..." ]; then
    unset CONFIG_DEV
    USE_KMEM_CACHE=y
    USE_KMEM_TIMER=y
else
    CONFIG_DEV=y
    unset USE_KMEM_CACHE
    unset USE_KMEM_TIMER
fi

#
# Red Hat 7.1 needs a kludge related to including highmem.h from vmalloc.h.
#
if [ "$TARGET" = "l" ]; then
    if [ -f $KSRC/include/linux/vmalloc.h ]; then
	if grep -q "Red Hat Linux 7.1" /proc/version &&
	   grep -q 'highmem\.h' $KSRC/include/linux/vmalloc.h; then
	    RH_71_KLUDGE=y
	fi
    fi
fi

#
# 2.4.20 (or thereabouts) changed the location of the signal mask lock
#
# Must set default to no.
SIGMASKLOCK=n

if [ "$TARGET" = "l" ]; then
    if [ -f $KSRC/include/linux/sched.h ]; then
	if grep -q 'sigmask_lock' $KSRC/include/linux/sched.h; then
	    SIGMASKLOCK=y
	fi
    elif [ "$KVER_MAJORMINOR" = "2.4" -a $KVER_PATCHNO -ge 20 ]; then
	    SIGMASKLOCK=y
    elif [ "$KVER_MAJORMINOR" = "2.5" ]; then
	    SIGMASKLOCK=y
    elif [ "$KVER_MAJORMINOR" = "2.6" ]; then
	    SIGMASKLOCK=y
    elif [ $KVER_MAJOR -ge 3 ]; then
            SIGMASKLOCK=y
    fi
fi

#
# Red Hat changed the number of arguments in recalc_sigpending
#
if [ "$TARGET" = "l" ]; then
    if [ -f $KSRC/include/linux/sched.h ]; then
	if grep -q 'recalc_sigpending(void)' $KSRC/include/linux/sched.h; then
	    RCVOID=y
	fi
    elif [ -f /usr/src/linux/include/linux/sched.h ]; then
	if grep -q 'recalc_sigpending(void)' \
		/usr/src/linux/include/linux/sched.h; then
	    RCVOID=y
	fi
    fi
fi


#
# Decide which C compiler to use.  gcc 2.96 is buggy, so try to use
# something better if it is present.
#
# The default is plain old gcc with -O2.
#
get_cc_from_makefile()
{
    make --no-print-directory -C $KSRC script 'SCRIPT=@echo $(CC)' | \
        sed -e 's/ .*//'
}

if   [ "$TARGET" = "l"  ]; then
    export KERN_CC_VERS=`kernel_cc_version`
    if [ "$KERN_CC_VERS..." = "..." ]; then
	echo
	echo "Could not determine the version of C compiler that was used"
	echo "to build your kernel.  Installation will proceed using the"
	echo "standard gcc compiler version `C_compiler_version gcc`, but"
	echo "there may be problems when you try to run LiS."
	echo
	do_confirm
	CC_NAME=gcc
	CC_VERS=`C_compiler_version gcc`
    else
	export CC_NAME=`pick_a_c_compiler`
	if [ "$CC_NAME..." = "..." ]; then
	    echo
	    echo "Could not identify a C compiler of version $KERN_CC_VERS."
	    echo "This compiler was used to compile your kernel and should"
	    echo "be used to compile LiS.  Installation will proceed using"
	    echo "the standard gcc compiler version `C_compiler_version gcc`,"
	    echo "but there may be problems when you try to run LiS."
	    echo
            # this is informative and should not block a batch configuration.
            if [ "$OPT_NATIVECOMPILER..." = "..." ] ;then
	    do_confirm
            fi
	    CC_NAME=gcc
	    CC_VERS=`C_compiler_version gcc`
	else
	    CC_VERS=`C_compiler_version cc`
	fi
    fi

    case $CC_NAME in
    kgcc)	CC_OPTIMIZE=-O3;;
    egcs)	CC_OPTIMIZE=-O3;;
    gcc3)	CC_OPTIMIZE=-O3;;
    gcc)	CC_OPTIMIZE=-O2;;
    cc)		CC_OPTIMIZE=-O2;;
    *)		CC_OPTIMIZE=-O2;;
    esac
    if [ $CROSS_COMPILING = "n" ]; then
        if $CC_NAME -mpreferred-stack-boundary=2 -S -o /dev/null \
	    -xc /dev/null >/dev/null 2>&1
        then
	    CC_OPT2=-mpreferred-stack-boundary=2
	fi
    fi
else
    echo
    echo "Non-Linux install.  Using cc as default C compiler."
    echo
    CC_NAME=cc
    CC_OPTIMIZE=-O
    CC_VERS=`C_compiler_version cc`
fi

if [ "$CC_VERS..." = "3.0.2..." ]; then
    echo
    echo "Compiler $CC_NAME $GCC_VERS is known to be buggy when"
    echo "compiling kernel code such as LiS.  You will probably"
    echo "experience problems, and perhaps crashes, when running LiS."
    echo
    do_confirm
fi

$qecho "Using \"$CC_NAME $CC_OPTIMIZE $CC_OPT2\" $CC_VERS as the C compiler"

#
# Figure out which routine name to use for "get_empty_inode".
#
get_empty_inode_option
#
# Figure out whether or not set_cpus_allowed is defined in this kernel
#
set_cpus_allowed_option

#
# Some architectures need an additional include directory
# When installing with no kernel source we will use /usr/src/linux anyway
# and just hope that this stuff got installed even though the rest of the
# source is not there.
#
if [ -e ${KSRC}/include/asm/mach-generic ]; then
	KINCL_MACH_GENERIC="-I${KSRC}/include/asm/mach-generic"
elif [ -e ${KBIN}/include2/asm/mach-generic ]; then
	KINCL_MACH_GENERIC="-I${KBIN}/include2/asm/mach-generic"
elif [ -e $KSRC/arch/x86/ ] && [ "$MACHINE" = "x86_64" ] \
          && [ ${KVER_MAJOR} -ge 3  ]; then
       if [ ${KVER_MAJOR} -ge 5 ]; then
            KINCL_MACH_GENERIC="-I/usr/src/include" 
       else
            KINCL_MACH_GENERIC="-I${KSRC}/arch/x86/include"
       fi
elif [ -e ${KBIN}/include/generated ]; then
	KINCL_MACH_GENERIC="-I${KSRC}/include/generated"
fi
#
if [ -e ${KSRC}/include/asm/mach-default ]; then
	KINCL_MACH_DEFAULT="-I${KSRC}/include/asm/mach-default"
elif [ -e ${KBIN}/include2/asm/mach-default ]; then
	KINCL_MACH_DEFAULT="-I${KBIN}/include2/asm/mach-default"
elif [ -e $KSRC/arch/x86/ ] && [ "$MACHINE" = "x86_64" ] \
          && [ ${KVER_MAJOR} -ge 3  ]; then
    if [ $KVER_MAJOR -ge 5 ]; then
       KINCL_MACH_DEFAULT="-I${KSRC}/include"
    elif [ -e ${KSRC}/include/generated ]; then
       KINCL_MACH_DEFAULT="-I${KSRC}/arch/x86/include/generated"
    fi
elif [ -e $KSRC/arch/powerpc/ ] && [ "$MACHINE" = "ppc64le" ] \
          && [ ${KVER_MAJOR} -ge 3  ]; then
    if [ -e ${KSRC}/include/generated ]; then
       KINCL_MACH_DEFAULT="-I${KSRC}/arch/powerpc/include/generated"
    fi
elif [ -e $KSRC/arch/s390/ ] && [ "$MACHINE" = "s390x" ] \
          && [ ${KVER_MAJOR} -ge 3  ]; then
    if [ $KVER_MAJOR -ge 5 ]; then
       if [ -e ${KSRC}/include/uapi ]; then
          KINCL_MACH_DEFAULT="-I${KSRC}/arch/s390/include/generated/uapi"
	  KINCL_MACH_GENERIC="-I${KSRC}/arch/s390/include/generated"
       fi
    else
       if [ -e ${KSRC}/include/uapi ]; then
          KINCL_MACH_DEFAULT="-I${KSRC}/include/uapi"
       fi
    fi	
fi
# Set LINUX_TYPE to indicate RPM or Debian type (RHEL/SLES verses UBUNTU)
LINUX_TYPE=RPM
MAKEDIRTYPE=SUBDIRS
# 5.3 and higher must have dummy Modules.symvers file
if [ $KVER_MAJOR -ge 5 -a $KVER_MINOR -ge 3 ]; then
     TOUCHSYMVERS=y
     MAKEDIRTYPE=M
     echo " TOUCHSYMVERS is set the 'y' for all to see!!"
fi
#
UBUNTU=`grep -i "ubuntu" /etc/os-release 2>/dev/null | wc -l`
if [ $UBUNTU -ne 0 ]; then
   LINUX_TYPE=DEBIAN
   SPLITUSERKERNEL=y
   NO32OVER64BUILD=y
   MAKEDIRTYPE=M
# Test for Split User/Kernel and 32over64build need
#  next test of PPC64le
elif [ "$MACHINE" = "ppc64le" ]; then
       SPLITUSERKERNEL=y
       NO32OVER64BUILD=y
# For SLES 15, RHEL 8 and later on s390x... not 32bit compatibility
elif [ "$MACHINE" = "s390x" ]; then
   if [ ${KVER_MAJOR} -ge 5  ] || [ $KVER_MAJOR -eq 4 -a $KVER_MINOR -ge 12 ]; then
       SPLITUSERKERNEL=y
       RHEL8=`grep "Red Hat Enterprise Linux 8" /etc/os-release 2>/dev/null | wc -l`
       SLES15=`grep "Enterprise Server 15" /etc/os-release 2>/dev/null | wc -l`
       if [ $RHEL8 -ne 0 ] || [ $SLES15 -ne 0 ]; then
          NO32OVER64BUILD=y
       fi
   fi   
fi
# For SLES 15 SP2 SPLITUSERKERNEL and NO32OVER64BUILD is set
if [ $KVER_MAJOR -ge 5 ]; then
   SPLITUSERKERNEL=y
   NO32OVER64BUILD=y
fi
# the following checks for post-2.4 kernels by version, but also
# sets some other related variables
#
check_kbuild


# identify GENCONF so we can create it here - it's a kosher config-time
# output (captures config info, lives inside the source tree, and building
# it from the top Makefile tends to make things circularly dependent)
#
GENCONF=${GENCONF:-${SRCDIR}/include/sys/LiS/genconf.h}

# create in each Makefile-containing directory a .config_mk file which can be
# included locally.  It in turn will include configuration-related make
# files or variables.  This allows any such directory to be made without
# starting at the top level (i.e., make -C <subdir>).  The existence of
# these files also signals that Configure has been run.
#
# note that CONFIG isn't additionally path-prefixed here, since we took
# care of expanding it above to include and absolute path prefix

# delete any old .config_mk files before writing new ones
#
find ${SRCDIR} -name \.config_mk -exec rm {} \;

# find the subdirs with Makefile's in them
#
MAKE_DIRS=$(find ${SRCDIR} -follow -name Makefile -print | \
 	sed "s:^${SRCDIR}/::" | sed "s:/Makefile$::" | sed "s:^Makefile$:.:")

# clean up the list - convert it to the positional parms array, and set it
# again from that array.  This gets rid of newlines, extra whitespace, etc.
#
set -- ${MAKE_DIRS}
MAKE_DIRS="${@}"

# use the list to write a .config_mk in each directory.  We do this as
# a top-level file in SRCDIR and symlinks everywhere else
#
cat > ${SRCDIR}/.config_mk <<EOF
include ${CONFIG}
include ${SRCDIR}/config.mk
include ${SRCDIR}/quiet.mk
include ${SRCDIR}/version
EOF
for d in $MAKE_DIRS; do
    [ ! -f ${d}/.config_mk ] && ln -sf ${SRCDIR}/.config_mk ${d}/.config_mk || :
done

#
# Finally output configuration file
#

cfg_out()
{
    if [ $# = 2 ]; then
        echo "$1=$2" >>$CONFIG
    else
        echo "# $1 is not set" >>$CONFIG
    fi
}

cfg_out_str()
{
    if [ $# = 2 ]; then
        echo "$1=\"$2\"" >>$CONFIG
    else
        echo "# $1 is not set" >>$CONFIG
    fi
}

echo "" >$CONFIG
echo "# THIS FILE WAS GENERATED.  MANUAL CHANGES MAY BE LOST." >>$CONFIG
echo "" >>$CONFIG
cfg_out_str CONFIG_OPTS "$CONFIG_OPTS"
cfg_out CONFIG $CONFIG
cfg_out SRCDIR $SRCDIR
cfg_out GENCONF $GENCONF
cfg_out CONFIG_STREAMS $CONFIG_STREAMS
cfg_out NO32OVER64BUILD $NO32OVER64BUILD
cfg_out SPLITUSERKERNEL $SPLITUSERKERNEL
cfg_out TOUCHSYMVERS $TOUCHSYMVERS
cfg_out TARGET $TARGET
cfg_out LINUX_TYPE $LINUX_TYPE
if [ "$TARGET" = "l" ]; then
    cfg_out CROSS_COMPILING $CROSS_COMPILING
    cfg_out KSRC $KSRC
    cfg_out KBIN $KBIN
    cfg_out KINCL $KINCL
    cfg_out NOKSRC $NOKSRC
    cfg_out KARCHINCL $KARCHINCL
    cfg_out KARCHINCL2 $KARCHINCL2
    cfg_out KARCHINCL3 $KARCHINCL3
    cfg_out KARCHINCL4 $KARCHINCL4 
    cfg_out USE_RUNNING_KERNEL $USE_RUNNING_KERNEL
    cfg_out NKVER $NKVER
    cfg_out KVER $KVER
    cfg_out KVER_MAJOR $KVER_MAJOR
    cfg_out KVER_MINOR $KVER_MINOR
    cfg_out KVER_PATCH $KVER_PATCH
    cfg_out KVER_PATCHNO $KVER_PATCHNO
    cfg_out KVER_MAJORMINOR $KVER_MAJORMINOR
    cfg_out KVER_H $KVER_H
    cfg_out NKVER_H $NKVER_H
    cfg_out KSMP $KSMP
    cfg_out KMODULES $KMODULES
    cfg_out KMODVERS $KMODVERS
    cfg_out LISMODVERS $LISMODVERS
    cfg_out LISAUTOCONF $LISAUTOCONF
    cfg_out IPV6 $IPV6
    cfg_out IPV6_MODULE $IPV6_MODULE
    cfg_out CONFIG_MK_KERNEL $CONFIG_MK_KERNEL 
    cfg_out STRMS_QUEUES $STRMS_QUEUES
    cfg_out MOD_INST_DIR $MOD_INST_DIR
    cfg_out MOD_INSTALL $MOD_INSTALL
    cfg_out RH_71_KLUDGE $RH_71_KLUDGE
    cfg_out SIGMASKLOCK $SIGMASKLOCK
    cfg_out RCVOID $RCVOID
    cfg_out MACHINE $MACHINE
    cfg_out CC_NAME $CC_NAME
    cfg_out CC_VERS $CC_VERS
    cfg_out CC_OPTIMIZE "$CC_OPTIMIZE"
    cfg_out CC_OPT2 "$CC_OPT2"
    cfg_out KINCL_MACH_GENERIC ${KINCL_MACH_GENERIC}
    cfg_out KINCL_MACH_DEFAULT ${KINCL_MACH_DEFAULT}
    cfg_out_str GET_EMPTY_INODE ${GET_EMPTY_INODE}
    cfg_out SET_CPUS_ALLOWED $SET_CPUS_ALLOWED
    #cfg_out REGISTER_SYSCALLS $REGISTER_SYSCALLS
    cfg_out INT_PSW $INT_PSW
    cfg_out CONFIG_DEV $CONFIG_DEV
    cfg_out USE_KMEM_CACHE $USE_KMEM_CACHE
    cfg_out USE_KMEM_TIMER $USE_KMEM_TIMER
    cfg_out LIS_MAJOR_BASE ${OPT_DEVICEBASE:-231}
    cfg_out CONFIG_INET $OPT_INET
    cfg_out PKGCOMPILE $OPT_PKGCOMPILE
    cfg_out PKGMODULES $OPT_PKGMODULES
    cfg_out SILENT_BUILD y
    cfg_out KBUILD $KBUILD
    cfg_out KBUILD_NEEDS_MODNAME $KBUILD_NEEDS_MODNAME
    cfg_out KBUILD_NEEDS_SYMVERS $KBUILD_NEEDS_SYMVERS
    cfg_out KBUILD_STR $KBUILD_STR
    cfg_out MODUTILS $MODUTILS
    cfg_out MODULE_INIT_TOOLS $MODULE_INIT_TOOLS
    cfg_out KSYMVERS $KSYMVERS
    cfg_out MAKEDIRTYPE $MAKEDIRTYPE
elif [ "$TARGET" = "u" ]; then
    cfg_out CONFIG_DEV y
fi
cfg_out CCREGPARM "$CCREGPARM"
cfg_out STREAMS_REGPARM "$STREAMS_REGPARM"
cfg_out LIS_OLD_CONSTS $LIS_OLD_CONSTS
cfg_out SOLARIS_STYLE_CMN_ERR $SOLARIS_STYLE_CMN_ERR
cfg_out DBG_OPT $DBG_OPT
cfg_out LIS_SHLIB $LIS_SHLIB
cfg_out package ${package}
cfg_out prefix ${prefix}
cfg_out execprefix ${execprefix}
cfg_out includedir ${includedir}
cfg_out libdir ${libdir}
cfg_out bindir ${bindir}
cfg_out sbindir ${sbindir}
cfg_out sysconfdir ${sysconfdir}
cfg_out datadir ${datadir}
cfg_out pkgincludedir ${pkgincludedir}
cfg_out pkglibdir ${pkglibdir}
cfg_out pkgdatadir ${pkgdatadir}
cfg_out pkgsrcdir ${pkgsrcdir}
cfg_out mandir ${mandir}
cfg_out modsubdir ${modsubdir}
cfg_out_str MAKE_DIRS "$MAKE_DIRS"

# we know CONFIG now exists - create GENCONF; the script needs SRCDIR &
# CONFIG, & reads the just-created CONFIG
#
SRCDIR=${SRCDIR} CONFIG=${CONFIG} ${SRCDIR}/mkgenconf

if [ "$MAKE_INVOKED" != "y" ]; then
    $qecho
    $qecho "Warning:"
    $qecho \
"You did not use \"make\" or \"make configure\" to run this configuration"
    $qecho \
"script.  You can now just run \"make\" for the the top LiS source" 
    $qecho \
"directory, but you should run \"make config\" before directly making any"
    $qecho \
"of the LiS subdirectories that have a 'Makefile'."
fi
