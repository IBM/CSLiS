<html>



<head>

<title>CSLiS Drivers</title>
<meta name="title" content="CSLiS Drivers">
<meta name="keywords" content="Linux, streams, drivers, CSLiS">
<meta name="description" content="Drivers and CSLiS">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">

<style type="text/css">

<!--

h2 {  font-family: Arial, Helvetica, sans-serif}

h1 {  font-family: Arial, Helvetica, sans-serif}

h3 {  font-family: Arial, Helvetica, sans-serif}

p {  font-family: Arial, Helvetica, sans-serif; font-size: 12pt}

a {  font-family: Arial, Helvetica, sans-serif; color: #0000FF}

a:link {  font-family: Arial, Helvetica, sans-serif; color: #0000FF}

a:hover {  font-family: Arial, Helvetica, sans-serif; color: #FF3333}

li {  font-family: Arial, Helvetica, sans-serif; font-size: 10pt}

ol {  font-family: Arial, Helvetica, sans-serif; font-size: 10pt}

-->

</style>

<script language="JavaScript">

<!--

function MM_swapImgRestore() { //v3.0

  var i,x,a=document.MM_sr; for(i=0;a&&i<a.length&&(x=a[i])&&x.oSrc;i++) x.src=x.oSrc;

}



function MM_preloadImages() { //v3.0

  var d=document; if(d.images){ if(!d.MM_p) d.MM_p=new Array();

    var i,j=d.MM_p.length,a=MM_preloadImages.arguments; for(i=0; i<a.length; i++)

    if (a[i].indexOf("#")!=0){ d.MM_p[j]=new Image; d.MM_p[j++].src=a[i];}}

}



function MM_findObj(n, d) { //v3.0

  var p,i,x;  if(!d) d=document; if((p=n.indexOf("?"))>0&&parent.frames.length) {

    d=parent.frames[n.substring(p+1)].document; n=n.substring(0,p);}

  if(!(x=d[n])&&d.all) x=d.all[n]; for (i=0;!x&&i<d.forms.length;i++) x=d.forms[i][n];

  for(i=0;!x&&d.layers&&i<d.layers.length;i++) x=MM_findObj(n,d.layers[i].document); return x;

}



function MM_swapImage() { //v3.0

  var i,j=0,x,a=MM_swapImage.arguments; document.MM_sr=new Array; for(i=0;i<(a.length-2);i+=3)

   if ((x=MM_findObj(a[i]))!=null){document.MM_sr[j++]=x; if(!x.oSrc) x.oSrc=x.src; x.src=a[i+2];}

}

//-->

</script>

</head>







<body bgcolor="#FFFFFF" onLoad="MM_preloadImages('i/kernel_on.gif','i/download_on.gif','i/install_on.gif','i/removal_on.gif','i/loading_on.gif','i/drivers_on.gif','i/config_on.gif','i/demand_on.gif','i/compiled_on.gif','i/apps_on.gif','i/otherres_on.gif','i/command_on.gif','i/dki_on.gif','i/libs_on.gif','i/lisdrvrs_on.gif')">
<table width="700" border="0" cellspacing="0" cellpadding="0" height="120" bgcolor="#6666CC">

	 <tr> 

		  <td width="120" height="120" rowspan="3"><a href="index.html"><img src="i/penguin.gif" width="120" height="120" border="0"></a></td>

		  <td rowspan="3" width="570" height="120" align="center" valign="middle"> 

			   <h1><font color="#FFFFFF" style="font-size:30pt;">Communications Server Linux STREAMS (CSLiS)</font></h1>

			 </td>

		  <td bgcolor="#ffffff" rowspan="3" width="10" height="120"><img src="./i/sideborder.gif" width="10" height="130"></td>

	 </tr>

	 <tr> </tr>

	 <tr> </tr>

</table>

<img src="./i/bottomborder.gif" width="703" height="15"> <br>

<table width="700" border="0" cellspacing="0" cellpadding="0">

  <tr> 

    <td rowspan="2" width="100" align="left" valign="top"> 
      <table width="90" border="0" cellspacing="0" cellpadding="0">
        <tr> 
          <td><a href="kernel.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('kernel','','i/kernel_on.gif',1)"><img name="kernel" border="0" src="i/kernel_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="download.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('download','','i/download_on.gif',1)"><img name="download" border="0" src="i/download_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="install.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('install','','i/install_on.gif',1)"><img name="install" border="0" src="i/install_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="removal.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('removal','','i/removal_on.gif',1)"><img name="removal" border="0" src="i/removal_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="loading.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('loading','','i/loading_on.gif',1)"><img name="loading" border="0" src="i/loading_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="drivers.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('drivers','','i/drivers_on.gif',1)"><img name="drivers" border="0" src="i/drivers_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="config.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('config','','i/config_on.gif',1)"><img name="config" border="0" src="i/config_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="demand.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('demand','','i/demand_on.gif',1)"><img name="demand" border="0" src="i/demand_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="compiled.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('compiled','','i/compiled_on.gif',1)"><img name="compiled" border="0" src="i/compiled_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="apps.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('apps','','i/apps_on.gif',1)"><img name="apps" border="0" src="i/apps_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="otherres.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('otherres','','i/otherres_on.gif',1)"><img name="otherres" border="0" src="i/otherres_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="cmds.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('cmds','','i/command_on.gif',1)"><img name="cmds" border="0" src="i/command_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="dki.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('dki','','i/dki_on.gif',1)"><img name="dki" border="0" src="i/dki_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="libc.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('libs','','i/libs_on.gif',1)"><img name="libs" border="0" src="i/libs_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="drvrs.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('lisdrvrs','','i/lisdrvrs_on.gif',1)"><img name="lisdrvrs" border="0" src="i/lisdrvrs_off.gif" width="81" height="35"></a></td>
        </tr>
      </table>
    </td>

    <td width="600" height="75"> 

      <div align="center"> 

        <h2>CSLiS Drivers</h2>

      </div>

    </td>

  </tr>

  <tr> 

    <td width="600" height="100%" align="left" valign="top"> 
      <h3><a name="Contents"></a><br>
        Contents </h3>
      <p><a href="#Introduction">Introduction</a> </p>
      <p>STREAMS Drivers </p>
      <blockquote><a href="#clone-drvr">clone-drvr</a> <br>
        <a href="#fifo">fifo</a> <br>
        <a href="#loop-around">loop-around</a> <br>
        <a href="#mini-mux">mini-mux</a> <br>
        <a href="#printk">printk</a> <br>
        <a href="#sad">sad</a></blockquote>
      <p>Pushable Modules </p>
      <blockquote><a href="#connld">connld</a> <br>
        <a href="#relay">relay</a> <br>
        <a href="#relay">relay2</a> </blockquote>
      <hr>
      <p><br>
        &nbsp; </p>
      <h2><a name="Introduction"></a>Introduction</h2>
      <p><br>
        The CSLiS package comes with a number of STREAMS drivers and pushable modules 
        in source code form.&nbsp; A number of these drivers and modules are small 
        entities that are used in the testing of CSLiS.&nbsp; They are included 
        so as to make it easy for any user to run the CSLiS tests for themselves. 
      </p>
      <p>Other drivers are used to interface between STREAMS and the Linux networking 
        subsystem (link-drvr, ip_strms).&nbsp; Still others are used to implement 
        STREAMS based pipes and FIFOs. </p>
      <p>A driver in STREAMS has a major and minor device number associated with 
        it and an entry in the /dev directory.&nbsp; The driver is opened and 
        closed just like any file. </p>
      <p>A pushable module in STREAMS is an entity that is added to an existing 
        STREAMS file via the <font face="Courier New, Courier, mono">I_PUSH</font> 
        ioctl.&nbsp; These modules are known to CSLiS by mnemonic name, given as 
        an argument to the <font face="Courier New, Courier, mono">I_PUSH</font> 
        ioctl.&nbsp; There are no major and minor device numbers or /dev entries 
        associated with pushable modules. </p>
      <p>This document is broken down into two sections.&nbsp; The STREAMS drivers 
        and pushable modules are documented separately.&nbsp; The driver names 
        used in this document are the declared names that appear in the CSLiS <font face="Courier New, Courier, mono">Config</font> 
        file for the particular driver. </p>
      <p><a href="#Contents">Back to Contents</a> </p>
      <hr>
      <br>
      <h2><a name="clone-drvr"></a>clone-drvr</h2>
      <h4>Device Name</h4>
      <p><font face="Courier New, Courier, mono">/dev/clone_drvr</font> </p>
      <h4>Description</h4>
      <p>This driver is used to assist CSLiS in implementing the &quot;clone&quot; 
        open function.&nbsp; It appears under its own name as <font face="Courier New, Courier, mono">/dev/clone_drvr</font>.&nbsp; 
        By convention, it is allocated the first major number of all the STREAMS 
        drivers. </p>
      <p>In order to implement clone opens, one creates a node in the /dev directory 
        for a device whose major number is set to that of the clone driver, and 
        whose minor number is the major number of the driver to which the clone 
        open is to be directed. </p>
      <p>The clone driver's open routine forwards the open call to the target 
        driver, passing a unique flag that informs the driver that a clone open 
        is being requested.&nbsp; The target driver then allocated a minor device 
        number to uniquely associate with this instance of the open operation.&nbsp; 
        The clone driver synthesizes a new major/minor &quot;device id&quot; to 
        pass back to CSLiS.&nbsp; CSLiS recognizes the change of major/minor from 
        the original open and takes steps to allocate control structures unique 
        to this open. </p>
      <p>The &quot;clone open&quot; operation is intended to make is easy to open 
        one device from a pool of devices, such as pseudo ttys or logical connections.&nbsp; 
        It saves application programs from having to scan a list of device mnemonics 
        issuing trial opens until one is found that succeeds. </p>
      <p>Note that the driver is named <font face="Courier New, Courier, mono">/dev/clone_drvr</font> 
        instead of the more traditional SVR4 <font face="Courier New, Courier, mono">/dev/clone</font>. 
        This is to avoid a conflict with another driver named <font face="Courier New, Courier, mono">/dev/clone</font> 
        on Linux systems.<br>
        &nbsp; </p>
      <h4>Author</h4>
      <p>David Grothe &lt;dave@gcom.com&gt; <br>
        &nbsp; </p>
      <p><a href="#Contents">Back to Contents</a> </p>
      <hr>
      <p>&nbsp; </p>
      <h2><a name="fifo"></a>fifo</h2>
      <h4>Device Name</h4>
      <p><font face="Courier New, Courier, mono">/dev/fifo </font>(clone device)<font face="Courier New, Courier, mono"> 
        <br>
        /dev/fifo.0 </font></p>
      <h4>Description</h4>
      <p>The fifo pseudo-driver (which is internal to CSLiS) provides STREAMS-based 
        fifos as single character special files, and STREAMS-based pipes as pairs 
        of character special files which are interconnected (see pipe(3)). </p>
      <p>STREAMS-based fifos differ from typical STREAMS-based character special 
        files in that there are not separate stream head and driver queue pair 
        within the STREAMS-based file. Instead, a fifo is created with only a 
        single queue pair for the stream head. Moreover, in a typical driver queue 
        pair, the write queue is not connected to a next queue. In a fifo, the 
        write queue is directed to the read queue of the pair. A pipe comprises 
        a pair of fifos, with the write queue of each pair directed to the read 
        queue of the other. The two fifos comprising a pipe are referred to as 
        peers, and each somewhat represents a driver to the other. As a degenerate 
        case, a fifo is its own peer. </p>
      <p>STREAMS modules may be pushed onto fifos and pipes, but should not expect 
        a driver below them; instead, the SAMESTR() function should be used from 
        the write queue of a pair to determine if the module is the lowest in 
        the STREAMS-based file (this is called the midpoint). The structure of 
        a fifo or pipe is preserved when modules are pushed (and popped); i.e., 
        the write queue at the midpoint will always be directed at the read queue 
        of the peer. </p>
      <p>Input and output are handled at a fifo stream head as they would normally 
        be handled at a stream head. In CSLiS, an fifo open() entry point exists 
        to assign minor device numbers to new opens under the fifo major device 
        number, and a close() entry point is used correspondingly to release them. 
        These functions are kept in a streamtab data struc&shy; ture (as they 
        would normally be for any STREAMS driver or module) which is private to 
        the CSLiS implementation. </p>
      <h4>Application Usage</h4>
      <p>In the current Linux kernels, character special major numbers are limited 
        to 16 bits, and major and minor device numbers to 8 bits each. This limits 
        a system to 256 total major device numbers and 256 total minor devices 
        per major device number. This is a rather severe limitation where mechanisms 
        like fifos and pipes are concerned. </p>
      <p>However, a driver may handle more than one major device number. The fifo 
        pseudo-driver uses this to overcome this limitation, by supporting the 
        automatic allocation and use of multiple major device numbers for fifos 
        and pipes.&nbsp; Specifying more than 256 minor devices is done in the 
        usual manner, i.e., by specifying the number of &quot;units&quot; in the 
        appropriate <font face="Courier New, Courier, mono">Config</font> file. 
        Enough major device numbers will be allocated to cover the requested number 
        of minor devices (if available, else an error will occur in <font face="Courier New, Courier, mono">strconf</font>(8)). 
        The number allocated will include one minor device per major number to 
        be used as a fifo-specific clone minor device (specifically, minor number 
        0), which exhibits special behavior. </p>
      <p>Normally, when cloning is done via the clone pseudo-driver, the clone 
        major device number is used, along with the desired actual major number 
        as the minor device num&shy; ber. When an open() is performed on such 
        a device, the clone open() routine in turn calls the appropriate driver's 
        open(), with the sflag parameter set to <font face="Courier New, Courier, mono">CLONEOPEN</font>. 
        The driver's open() is expected in this case to allocate an unused minor 
        device number, and return it via an entirely new device number in the 
        devp parameter. In this way, a driver can change the device number to 
        be used for a STREAMS-based file. When minor device 0 for a specified 
        for a fifo major device, the driver will also clone a new minor device 
        number. However, CSLiS opens fifo devices differently; specifically, when 
        an already-opened fifo-specific clone minor device is reopened, the new 
        and subsequent opens will use the already-opened clone. Thus, using minor 
        device 0 for a fifo when creating a file sys&shy; tem node will ensure 
        that all concurrent opens of the associated path name will use the same 
        STREAMS-based file; at the same time, opens of different file system nodes 
        via different paths will open their respectively different STREAMS-based 
        files. This is essentially how kernel-based fifos behave -applications 
        and users of STREAMS-based fifos don't have to keep track of minor numbers 
        to achieve this same behavior when it is desired. </p>
      <p>It is in fact recommended that only two forms of file sys&shy; tem nodes 
        be used for STREAMS-based fifos: the clone major number as major number 
        with a fifo major number as minor number, to be used when every open of 
        the associated path must clone a new fifo, and a fifo major number as 
        major number with 0 as the minor number, to be used when new opens are 
        to clone a new fifo but subsequent concurrent opens are to use the already 
        opened fifo. These are represented by two device special file paths created 
        when CSLiS is installed: <font face="Courier New, Courier, mono">/dev/fifo</font> 
        for the former, and <font face="Courier New, Courier, mono">/dev/fifo.0</font> 
        for the latter. It is recommended that these be used, possibly along with 
        the equivalent of stat(2) to determine appropriate major device numbers 
        for the clone and fifo pseudo-drivers, which are also determined when 
        CSLiS is installed. It can be noted that pipes are actually created as instances 
        of the former, after which the write queues are peer-connected. </p>
      <p>The fifo pseudo-driver allocates minor devices in round-robin fashion; 
        i.e., a list of available minor devices is kept, and once a minor number 
        is finally closed, it is put at the end of this list. Thus, a fifo minor 
        device which is opened and closed will not be immediately reused. <br>
        &nbsp; </p>
      <h4>Warnings</h4>
      <p>Because STREAMS-based fifos and pipes are implemented as character special 
        devices, they do not appear as pipe devices when examined with stat(2) 
        or the equivalent (e.g., ls(1)); i.e. the S_IFIFO indication is not set 
        in the mode - S_IFCHR is set instead, and the actual device number is 
        indicated in the st_rdev field of the stat data structure. </p>
      <p>Because of the potential use of multiple major numbers, applications 
        should not depend on a fifo or pipe having a specific major device number, 
        nor should an application depend on all fifos and pipes having the same 
        major device number. <br>
        &nbsp; </p>
      <h4>See Also</h4>
      <p>clone(9), connld(9), fifo(4), ls(1), pipe(3), pipemod(9), STREAMS(4), 
        stat(2), strconf(8) <br>
        &nbsp; </p>
      <h4>Author</h4>
      <p>John Boyd, protologos LLC. &lt;jaboydjr@netwalk.com&gt; <br>
        &nbsp; </p>
      <p><a href="#Contents">Back to Contents</a> </p>
      <hr>
      <p><br>
      </p>
      <h2><a name="loop-around"></a>loop-around</h2>
      <h4>Device Name</h4>
      <p><font face="Courier New, Courier, mono">/dev/loop_clone</font> (clone 
        device) <br>
        <font face="Courier New, Courier, mono">/dev/loop.1 <br>
        /dev/loop.2</font> </p>
      <h4>Description</h4>
      <p>This driver is used by CSLiS and the <font face="Courier New, Courier, mono">strtst</font> 
        utility to assist in the regression testing of CSLiS.&nbsp; It connects 
        two streams together in a manner similar to that of a pipe.&nbsp; Messages 
        written into one stream can be read back from the other. </p>
      <p style="margin-bottom: 0in">The driver can be operated as a clone device 
        with the two streams being connected via ioctls.&nbsp; A number of ioctls 
        exist that tailor the operation of the driver.&nbsp; The user codes these 
        ioctls as type <tt>I_STR</tt> and passes a structure of type <tt>struct 
        strioctl</tt> to the driver.&nbsp; The <tt>ic_cmd</tt> field of this structure 
        is decoded according to the following table.&nbsp; the <tt>ic_dp</tt> 
        and <tt>ic_len</tt> fields delimit an argument structure which is also 
        passed to the driver.&nbsp; The argument structure differs for each type 
        of <tt>ic_cmd</tt>. <br>
        &nbsp; </p>
      <table width=670 border=1 cellpadding=2 cellspacing=3>
        <col width=127> <col width=145> <col width=372> 
        <tr valign=TOP> 
          <td width=127> 
            <p><font face="Courier New, Courier, mono">ic_cmd</font> value</p>
          </td>
          <td width=145> 
            <p>Argument Structure</p>
          </td>
          <td width=372> 
            <p>Description</p>
          </td>
        </tr>
        <tr valign=TOP> 
          <td width=127> 
            <p><font face="Courier New, Courier, mono">LOOP_SET</font></p>
          </td>
          <td width=145> 
            <p>IN: <font face="Courier New, Courier, mono">int</font></p>
          </td>
          <td width=372> 
            <p>Argument is the minor device number of the loop device to use for 
              the other end of the connection.&nbsp; If the loop-around device 
              had been opened by a directed open, such as to <font face="Courier New, Courier, mono">/dev/loop.1</font>, 
              then the minor device number is known from the device node.&nbsp; 
              If it was opened via the <font face="Courier New, Courier, mono">/dev/loop_clone</font> 
              device then the minor device can be discovered via the <font face="Courier New, Courier, mono">LOOP_GET_DEV</font> 
              <font face="Courier New, Courier, mono">ioctl</font>.</p>
          </td>
        </tr>
        <tr valign=TOP> 
          <td width=127> 
            <p><font face="Courier New, Courier, mono">LOOP_PUTNXT</font></p>
          </td>
          <td width=145> 
            <p>None</p>
          </td>
          <td width=372> 
            <p>Set the driver into a mode in which it will perform a direct putnext 
              call on the other stream rather than the default behavior of using 
              the service queue to forward the message.</p>
          </td>
        </tr>
        <tr valign=TOP> 
          <td width=127> 
            <p><font face="Courier New, Courier, mono">LOOP_MSGLVL</font></p>
          </td>
          <td width=145> 
            <p>IN: <font face="Courier New, Courier, mono">int</font></p>
          </td>
          <td width=372> 
            <p>Set to the number of messages to queue in the service queue before 
              forwarding to the other stream.&nbsp; Zero means forward immediately.</p>
          </td>
        </tr>
        <tr> 
          <td width=127 valign=TOP> 
            <p><font face="Courier New, Courier, mono">LOOP_TIMR</font></p>
          </td>
          <td width=145 valign=TOP> 
            <p>IN: <font face="Courier New, Courier, mono">int</font></p>
          </td>
          <td width=372> 
            <p>Set the number of &quot;ticks&quot; to hold messages before forwarding 
              them to the other stream.</p>
          </td>
        </tr>
        <tr> 
          <td width=127 valign=TOP> 
            <p><font face="Courier New, Courier, mono">LOOP_MARK</font></p>
          </td>
          <td width=145 valign=TOP> 
            <p>IN: <font face="Courier New, Courier, mono">int</font></p>
          </td>
          <td width=372> 
            <p>Set the <font face="Courier New, Courier, mono">MSGMARK</font> 
              flag for each of the next <i>n</i> messages before forwarding them 
              to the other stream.</p>
          </td>
        </tr>
        <tr> 
          <td width=127 valign=TOP> 
            <p><font face="Courier New, Courier, mono">LOOP_GET_DEV</font></p>
          </td>
          <td width=145 valign=TOP> 
            <p>OUT: <font face="Courier New, Courier, mono">int</font></p>
          </td>
          <td width=372> 
            <p>Return the minor device number of this stream.&nbsp; Useful for 
              finding out the minor number of a clone device.</p>
          </td>
        </tr>
        <tr> 
          <td width=127 valign=TOP> 
            <p><font face="Courier New, Courier, mono">LOOP_BUFCALL</font></p>
          </td>
          <td width=145 valign=TOP> 
            <p>None</p>
          </td>
          <td width=372> 
            <p>Use the <tt>bufcall</tt> mechanism to allocate a buffer for copying 
              the next message.</p>
          </td>
        </tr>
        <tr> 
          <td width=127 valign=TOP> 
            <p><font face="Courier New, Courier, mono">LOOP_CONCAT</font></p>
          </td>
          <td width=145 valign=TOP> 
            <p>IN: <font face="Courier New, Courier, mono">int</font></p>
          </td>
          <td width=372> 
            <p>Concatenate this many messages into a single message and then forward 
              on the other stream.&nbsp; One concatenation resets this value to 
              zero and the ioctl needs to be issued again to repeat the behavior.</p>
          </td>
        </tr>
        <tr> 
          <td width=127 valign=TOP> 
            <p><font face="Courier New, Courier, mono">LOOP_COPY</font></p>
          </td>
          <td width=145 valign=TOP> 
            <p>None</p>
          </td>
          <td width=372> 
            <p>From this point on, copy messages rather than passing them through 
              to the other stream.</p>
          </td>
        </tr>
      </table>
      <h4>Author</h4>
      <p>David Grothe &lt;dave@gcom.com&gt; plus others originally. </p>
      <p><a href="#Contents">Back to Contents</a> </p>
      <hr>
      <h2><a name="mini-mux"></a><br>
        mini-mux</h2>
      <h4>Device Name</h4>
      <p><font face="Courier New, Courier, mono">/dev/mux_clone</font> (clone 
        device)<br>
        <font face="Courier New, Courier, mono">/dev/minimux.1<br>
        /dev/minimux.2</font></p>
      <h4> <br>
        Description</h4>
      <p>This driver is used by CSLiS in its testing procedures. It is a small multiplexing 
        driver that allows cascaded multiplexors to be built and torn down. The 
        driver uses a pair of ioctls to establish connectivity between upper streams 
        and lower streams. This allows control over how data flows through the 
        multiplexor.</p>
      <p>Both of these ioctls are coded as type <tt>I_STR</tt> and pass a structure 
        of type <tt>struct strioctl</tt> to the driver.&nbsp; The <tt>ic_cmd</tt> 
        field of this structure is decoded according to the following table.&nbsp; 
        the <tt>ic_dp</tt> and <tt>ic_len</tt> fields delimit an argument structure 
        which is also passed to the driver.&nbsp; The argument structure may differ 
        for each type of <tt>ic_cmd</tt>.<br>
        &nbsp; </p>
      <table width=670 border=1 cellpadding=2 cellspacing=3>
        <col width=146> <col width=90> <col width=408> 
        <tr valign=TOP> 
          <td width=146> 
            <p><font face="Courier New, Courier, mono">ic_cmd</font> value</p>
          </td>
          <td width=90> 
            <p>Argument Structure</p>
          </td>
          <td width=408> 
            <p>Description</p>
          </td>
        </tr>
        <tr valign=TOP> 
          <td width=146> 
            <p><font face="Courier New, Courier, mono">MINIMUX_UP</font></p>
          </td>
          <td width=90> 
            <p>IN: <font face="Courier New, Courier, mono">int</font></p>
          </td>
          <td width=408> 
            <p>The argument is a muxid that was returned from an <font face="Courier New, Courier, mono">I_LINK</font> 
              ioctl. This ioctl causes the lower stream indicated by the muxid 
              to be connected to this stream. This is unidirectional linkage and 
              only affects the upstream flow of messages.</p>
          </td>
        </tr>
        <tr valign=TOP> 
          <td width=146> 
            <p><font face="Courier New, Courier, mono">MINIMUX_DOWN</font></p>
          </td>
          <td width=90> 
            <p>IN: <font face="Courier New, Courier, mono">int</font></p>
          </td>
          <td width=408> 
            <p>The argument is a muxid that was returned from an <font face="Courier New, Courier, mono">I_LINK</font> 
              ioctl. This ioctl causes this stream to be connected to the lower 
              stream indicated by the muxid. This is unidirectional linkage and 
              only affects the downstream flow of messages.</p>
          </td>
        </tr>
      </table>
      <p><br>
        <br>
      </p>
      <h4>Author</h4>
      <p>David Grothe &lt;<a href="mailto:dave@gcom.com">dave@gcom.com</a>&gt;</p>
      <p><a href="#Contents">Back to Contents</a> </p>
      <hr>
      <h2><a name="printk"></a>printk</h2>
      <h4>Device Name</h4>
      <p><font face="Courier New, Courier, mono">/dev/printk</font></p>
      <h4>Description</h4>
      <p>This driver accepts messages written to it and prints them from the kernel 
        using the kernel's <font face="Courier New, Courier, mono">printk</font> 
        function. It is used by the CSLiS test software to keep messages from CSLiS 
        and messages from the test program in sequence.</p>
      <h4>Author</h4>
      <p>David Grothe &lt;<a href="mailto:dave@gcom.com">dave@gcom.com</a>&gt;</p>
      <hr>
      <h2><a name="sad"></a>sad</h2>
      <h4>Device Name</h4>
      <p><font face="Courier New, Courier, mono">/dev/sad</font></p>
      <h4>Description</h4>
      <p>The STREAMS Administrative Driver manages the autopush function of CSLiS. 
        Using ioctls the system administrator can provide a list of modules that 
        are to be automatically pushed onto a given device when that device is 
        opened. The controls are specified via the <font face="Courier, monospace">strapush</font> 
        structure which is defined in <font face="Courier New, Courier, mono">&lt;sys/sad.h&gt;</font>.</p>
      <p>The ioctl used by the user is of the form:</p>
      <p style="margin-left: 0.79in"><font face="Courier, monospace">ioctl(fd, 
        command, arg)</font></p>
      <p>Where <font face="Courier, monospace">fd</font> is the file descriptor 
        of the file that is open to the sad driver, <font face="Courier, monospace">command</font> 
        and <font face="Courier, monospace">arg</font> are described in the following 
        table.</p>
      <table width=672 border=1 cellpadding=4 cellspacing=3>
        <col width=127> <col width=196> <col width=311> <thead> 
        <tr valign=TOP> 
          <th width=127> 
            <p align=LEFT>Command</p>
          </th>
          <th width=196> 
            <p align=LEFT>Argument</p>
          </th>
          <th width=311> 
            <p align=LEFT>Description</p>
          </th>
        </tr>
        </thead> <tbody> 
        <tr valign=TOP> 
          <td width=127> 
            <p align=LEFT><font face="Courier New, Courier, mono">SAD_SAP</font></p>
          </td>
          <td width=196> 
            <p align=LEFT><font face="Courier, monospace">struct strapush *</font></p>
          </td>
          <td width=311> 
            <p align=LEFT>Set the list of autopushed modules according to the 
              <font face="Courier, monospace">sap_cmd</font> and other arguments 
              contained within the <font face="Courier, monospace">strapush</font> 
              structure.</p>
          </td>
        </tr>
        <tr valign=TOP> 
          <td width=127> 
            <p align=LEFT><font face="Courier New, Courier, mono">SAD_GAP</font></p>
          </td>
          <td width=196> 
            <p align=LEFT><font face="Courier, monospace">struct strapush *</font></p>
          </td>
          <td width=311> 
            <p align=LEFT>Get the list of configured autopushed modules associated 
              with the indicated major and minor device number. The <font face="Courier, monospace">sad</font> 
              driver fills in this structure with the names of the modules and 
              the applicable range of minor device numbers.</p>
          </td>
        </tr>
        <tr valign=TOP> 
          <td width=127> 
            <p align=LEFT><font face="Courier New, Courier, mono">SAD_VML</font></p>
          </td>
          <td width=196> 
            <p align=LEFT><font face="Courier, monospace">struct str_list *</font></p>
          </td>
          <td width=311> 
            <p align=LEFT>Validates a list of pushable module names to verify 
              that they are installed in CSLiS. The <font face="Courier, monospace">str_list</font> 
              structure is defined in the file <font face="Courier New, Courier, mono">&lt;sys/stropts.h&gt;</font>.</p>
          </td>
        </tr>
        </tbody> 
      </table>
      <p>&nbsp; </p>
      <p>The <font face="Courier, monospace">strapush</font> structure used by 
        the <font face="Courier New, Courier, mono">SAD_SAP</font> and <font face="Courier New, Courier, mono">SAD_GAP</font> 
        ioctls contains the following fields.<br>
      </p>
      <table width=671 border=1 cellpadding=4 cellspacing=3>
        <col width=301> <col width=103> <col width=229> 
        <tr valign=TOP> 
          <th width=301> 
            <p align=LEFT>Field</p>
          </th>
          <th colspan=2 width=343> 
            <p align=LEFT>Description</p>
          </th>
        </tr>
        <tr valign=TOP> 
          <td rowspan=5 width=301> 
            <p><font face="Courier, monospace">unsigned sap_cmd</font></p>
          </td>
          <td colspan=2 width=343> 
            <p>This is the autopush command to be executed. The values are as 
              follows.</p>
          </td>
        </tr>
        <tr valign=TOP> 
          <td width=103> 
            <p><font face="Courier, monospace">SAP_ONE</font></p>
          </td>
          <td width=229> 
            <p>Configure one minor device of the driver indicated by <font face="Courier, monospace">sap_major</font>.</p>
          </td>
        </tr>
        <tr valign=TOP> 
          <td width=103> 
            <p><font face="Courier, monospace">SAP_RANGE</font></p>
          </td>
          <td width=229> 
            <p>Configure a range of minor devices of the driver indicated by sap_major. 
              The range runs from <font face="Courier, monospace">sap_minor</font> 
              to <font face="Courier, monospace">sap_lastminor</font>, inclusively.</p>
          </td>
        </tr>
        <tr valign=TOP> 
          <td width=103> 
            <p><font face="Courier, monospace">SAP_ALL</font></p>
          </td>
          <td width=229> 
            <p>Configure all minor devices of the driver indicated by <font face="Courier, monospace">sap_major</font>.</p>
          </td>
        </tr>
        <tr valign=TOP> 
          <td width=103> 
            <p><font face="Courier, monospace">SAP_CLEAR</font></p>
          </td>
          <td width=229> 
            <p>Undo all autopush configuration for the driver indicated by <font face="Courier, monospace">sap_major</font>.</p>
          </td>
        </tr>
        <tr valign=TOP> 
          <td width=301> 
            <p><font face="Courier, monospace">major_t sap_major</font></p>
          </td>
          <td colspan=2 width=343> 
            <p>The major device number of the driver which is being configured 
              for autopush.</p>
          </td>
        </tr>
        <tr valign=TOP> 
          <td width=301> 
            <p><font face="Courier, monospace">minor_t sap_minor</font></p>
          </td>
          <td colspan=2 width=343> 
            <p>The minor device being configured, or the first of a range.</p>
          </td>
        </tr>
        <tr valign=TOP> 
          <td width=301> 
            <p><font face="Courier, monospace">minor_t sap_lastminor</font></p>
          </td>
          <td colspan=2 width=343> 
            <p>The last minor device of a range to be configured.</p>
          </td>
        </tr>
        <tr valign=TOP> 
          <td width=301> 
            <p><font face="Courier, monospace">unsigned sap_npush</font></p>
          </td>
          <td colspan=2 width=343> 
            <p>Number of modules to be pushed when the indicated device is opened.</p>
          </td>
        </tr>
        <tr valign=TOP> 
          <td width=301> 
            <p><font face="Courier, monospace">char sap_list[MAXAPUSH][FMNAMESZ+1]</font></p>
          </td>
          <td colspan=2 width=343> 
            <p>List of module names to be pushed, or list of modules names returned 
              to user.</p>
          </td>
        </tr>
      </table>
      <p>&nbsp; </p>
      <p>The <font face="Courier New, Courier, mono">ioctl</font> function call 
        returns zero upon success or -1 on failure. Upon failure <font face="Courier New, Courier, mono">errno</font> 
        is set to the error number describing the failure, usually either <font face="Courier New, Courier, mono">EFAULT</font> 
        or <font face="Courier New, Courier, mono">EINVAL</font>.</p>
      <p>Note that the <font face="Courier, monospace">sad</font> driver is a 
        standard AT&amp;T STREAMS function. More comprehensive documentation for 
        this driver can be found in the <i><a href="otherres.html">SVR4 Programmer's 
        Guide: STREAMS</a></i>.</p>
      <h4>Author</h4>
      <p>Ole Husgaard &lt;sparre@login.dknet.dk&gt; </p>
      <p><a href="#Contents">Back to Contents</a> </p>
      <hr>
      <h2><a name="connld"></a>connld</h2>
      <h4>Module Name</h4>
      <p><font face="Courier New, Courier, mono">connld</font></p>
      <h4>Description</h4>
      <p>The connld module provides a means to generate multiple unique STREAMS-based 
        pipes from a single existing pipe end. connld may only be pushed (via 
        the STREAMS I_PUSH ioctl) onto a STREAMS-based pipe. When first pushed, 
        connld does nothing; on each subsequent open(2), connld will generate 
        a unique STREAMS-based pipe. One end of each new pipe replaces the original 
        pipe end from the perspective of the open call. The other end of each 
        new pipe is sent, effectively as if by the <font face="Courier New, Courier, mono">I_SENDFD</font> 
        <font face="Courier New, Courier, mono">ioctl</font>, to the other end 
        of the original pipe, ostensibly to be received by a subsequent <font face="Courier New, Courier, mono">I_RECVFD</font> 
        <font face="Courier New, Courier, mono">ioctl</font> operation.</p>
      <h4>Application Usage</h4>
      <p>The intent of connld is to provide a means to generate unique pipes which 
        separately and independently connect client processes to a server process. 
        The point of access for such clients is expected to be a path name known 
        to all such clients and to which a pipe end may be connected (via fattach(3)) 
        by the server process. The server establishes the original pipe, pushes 
        connld onto the client end, and then listens via <font face="Courier New, Courier, mono">I_RECVFD</font> 
        for new connections on the server end. A client wishing to connect to 
        the server will open(2) the path name representing the client end, and 
        can determine via isastream(3) whether or not the server process is active 
        and attached. If it is, the open() call returns one end of a unique new 
        pipe that thus connects the client to the server.</p>
      <p>Such a server is responsible both for accepting new connections via <font face="Courier New, Courier, mono">I_RECVFD</font> 
        on the original pipe, and for communicating with clients so connected 
        via the received pipe ends. It would also be reasonable for such a server 
        process to invalidate the point of access by calling fdetach(3) before 
        terminating.</p>
      <p>It should be noted that the poll(2) primitive may be used to indicate 
        when an <font face="Courier New, Courier, mono">M_PASSFP</font> representing 
        a newly passed file is available on the original server pipe end. This 
        is reflected by the <font face="Courier New, Courier, mono">POLLIN</font> 
        status setting in the events and revents fields of a <font face="Courier New, Courier, mono">pollfd</font> 
        structure. Moreover, any attempt to read an <font face="Courier New, Courier, mono">M_PASSFP</font> 
        message via the data-receiving primitives (i.e., read(2), getmsg(3), and 
        getpmsg(3)) will fail with errno(3) returning an <font face="Courier New, Courier, mono">EBADMSG</font> 
        indication without discarding the message.</p>
      <p>Even so, it should be reasonable to expect only <font face="Courier New, Courier, mono">M_PASSFP</font> 
        messages will be received on the original server pipe end, since it is 
        not possible to carry on normal data traffic which has <font face="Courier New, Courier, mono">connld</font> 
        on one end, since connld does not support such traffic.</p>
      <p>The use of <font face="Courier New, Courier, mono">connld</font> can 
        be made entirely free-standing by attaching well-known paths to both ends 
        of the original pipe. The relevant capabilities are implemented in CSLiS 
        so that the original creator of the pipe can close both ends after attaching 
        paths to them, and the process of passing file descriptors can still be 
        carried out via new open()'s as long as both ends remain attached.</p>
      <h4>See Also</h4>
      <p>fattach(3), fattach(8), fdetach(3), fifo(4), fifo(9),</p>
      <p>pipe(3), STREAMS(4)</p>
      <h4>History</h4>
      <p>Unix System V Release 4 (SVR4)</p>
      <h4>Author</h4>
      <p>John Boyd, protologos LLC. &lt;jaboydjr@netwalk.com&gt; </p>
      <p><a href="#Contents">Back to Contents</a> </p>
      <hr>
      <h2><a name="relay"></a>relay, relay2</h2>
      <h4>Module Name</h4>
      <pre><font face="Courier New, Courier, mono">relay
relay2</font></pre>
      <h4> Description</h4>
      <p>These are two names for the same module. All the module does is forward 
        STREAMS messages along on the stream using <font face="Courier New, Courier, mono">putnext</font>. 
        These modules are used in the testing of CSLiS but are not otherwise useful. 
        One could use the source code as a starting point for coding a pushable 
        STREAMS module.</p>
      <h4>Author</h4>
      <p>David Grothe &lt;<a href="mailto:dave@gcom.com">dave@gcom.com</a>&gt;</p>
      <p><a href="#Contents">Back to Contents</a> </p>
      <h2><br>
      </h2>
      </td>

  </tr>

</table>

<p align="left">&nbsp;</p>



</body>



</html>



