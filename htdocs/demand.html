<html>



<head>

<title>Demand loading CSLiS</title>
<meta name="title" content="Demand loading CSLiS">
<meta name="keywords" content="Linux, streams, demand, loading, CSLiS">
<meta name="description" content="About demand loading CSLiS">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">

<style type="text/css">

<!--

h2 {  font-family: Arial, Helvetica, sans-serif}

h1 {  font-family: Arial, Helvetica, sans-serif}

h3 {  font-family: Arial, Helvetica, sans-serif}

p {  font-family: Arial, Helvetica, sans-serif; font-size: 12pt}

a {  font-family: Arial, Helvetica, sans-serif; color: #0000FF}

a:link {  font-family: Arial, Helvetica, sans-serif; color: #0000FF}

a:hover {  font-family: Arial, Helvetica, sans-serif; color: #FF3333}

li {  font-family: Arial, Helvetica, sans-serif; font-size: 10pt}

ol {  font-family: Arial, Helvetica, sans-serif; font-size: 10pt}

-->

</style>

<script language="JavaScript">

<!--

function MM_swapImgRestore() { //v3.0

  var i,x,a=document.MM_sr; for(i=0;a&&i<a.length&&(x=a[i])&&x.oSrc;i++) x.src=x.oSrc;

}



function MM_preloadImages() { //v3.0

  var d=document; if(d.images){ if(!d.MM_p) d.MM_p=new Array();

    var i,j=d.MM_p.length,a=MM_preloadImages.arguments; for(i=0; i<a.length; i++)

    if (a[i].indexOf("#")!=0){ d.MM_p[j]=new Image; d.MM_p[j++].src=a[i];}}

}



function MM_findObj(n, d) { //v3.0

  var p,i,x;  if(!d) d=document; if((p=n.indexOf("?"))>0&&parent.frames.length) {

    d=parent.frames[n.substring(p+1)].document; n=n.substring(0,p);}

  if(!(x=d[n])&&d.all) x=d.all[n]; for (i=0;!x&&i<d.forms.length;i++) x=d.forms[i][n];

  for(i=0;!x&&d.layers&&i<d.layers.length;i++) x=MM_findObj(n,d.layers[i].document); return x;

}



function MM_swapImage() { //v3.0

  var i,j=0,x,a=MM_swapImage.arguments; document.MM_sr=new Array; for(i=0;i<(a.length-2);i+=3)

   if ((x=MM_findObj(a[i]))!=null){document.MM_sr[j++]=x; if(!x.oSrc) x.oSrc=x.src; x.src=a[i+2];}

}

//-->

</script>

</head>







<body bgcolor="#FFFFFF" onLoad="MM_preloadImages('i/kernel_on.gif','i/download_on.gif','i/install_on.gif','i/removal_on.gif','i/loading_on.gif','i/drivers_on.gif','i/config_on.gif','i/demand_on.gif','i/compiled_on.gif','i/apps_on.gif','i/otherres_on.gif','i/command_on.gif','i/dki_on.gif','i/libs_on.gif','i/lisdrvrs_on.gif')">
<table width="700" border="0" cellspacing="0" cellpadding="0" height="120" bgcolor="#6666CC">

	 <tr> 

		  <td width="120" height="120" rowspan="3"><a href="index.html"><img src="i/penguin.gif" width="120" height="120" border="0"></a></td>

		  <td rowspan="3" width="570" height="120" align="center" valign="middle"> 

			   <h1><font color="#FFFFFF" style="font-size:30pt;">Communicatons Server Linux STREAMS (CSLiS)</font></h1>

			 </td>

		  <td bgcolor="#ffffff" rowspan="3" width="10" height="120"><img src="./i/sideborder.gif" width="10" height="130"></td>

	 </tr>

	 <tr> </tr>

	 <tr> </tr>

</table>

<img src="./i/bottomborder.gif" width="703" height="15"> <br>

<table width="700" border="0" cellspacing="0" cellpadding="0">

  <tr> 

    <td rowspan="2" width="100" align="left" valign="top"> 
      <table width="90" border="0" cellspacing="0" cellpadding="0">
        <tr> 
          <td><a href="kernel.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('kernel','','i/kernel_on.gif',1)"><img name="kernel" border="0" src="i/kernel_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="download.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('download','','i/download_on.gif',1)"><img name="download" border="0" src="i/download_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="install.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('install','','i/install_on.gif',1)"><img name="install" border="0" src="i/install_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="removal.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('removal','','i/removal_on.gif',1)"><img name="removal" border="0" src="i/removal_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="loading.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('loading','','i/loading_on.gif',1)"><img name="loading" border="0" src="i/loading_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="drivers.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('drivers','','i/drivers_on.gif',1)"><img name="drivers" border="0" src="i/drivers_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="config.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('config','','i/config_on.gif',1)"><img name="config" border="0" src="i/config_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="demand.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('demand','','i/demand_on.gif',1)"><img name="demand" border="0" src="i/demand_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="compiled.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('compiled','','i/compiled_on.gif',1)"><img name="compiled" border="0" src="i/compiled_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="apps.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('apps','','i/apps_on.gif',1)"><img name="apps" border="0" src="i/apps_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="otherres.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('otherres','','i/otherres_on.gif',1)"><img name="otherres" border="0" src="i/otherres_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="cmds.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('cmds','','i/command_on.gif',1)"><img name="cmds" border="0" src="i/command_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="dki.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('dki','','i/dki_on.gif',1)"><img name="dki" border="0" src="i/dki_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="libc.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('libs','','i/libs_on.gif',1)"><img name="libs" border="0" src="i/libs_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="drvrs.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('lisdrvrs','','i/lisdrvrs_on.gif',1)"><img name="lisdrvrs" border="0" src="i/lisdrvrs_off.gif" width="81" height="35"></a></td>
        </tr>
      </table>
    </td>

    <td width="600" height="75"> 

      <div align="center"> 
        <h2><a name="demand_loading"></a>Demand loading CSLiS modules and drivers 
        </h2>

      </div>

    </td>

  </tr>

  <tr> 
    <td width="600" height="100%" align="left" valign="top"> 
      <p align="left">The CSLiS demand load system supports only the kernel 2.6 and later  
        kmod mechanisms for demand loading kernel modules. </p>
      <p>The convention for CSLiS kernel loadable object files is: </p>
      <ul>
        <li>Their name start with <tt>&quot;<font face="Courier New, Courier, mono">streams-</font>&quot;</tt>.</li>
        <li>They are placed in <tt><font face="Courier New, Courier, mono">/lib/modules/</font></tt><b><tt>&lt;kver&gt;</tt></b><tt><font face="Courier New, Courier, mono">/misc/</font></tt>, 
          where <b><tt>&lt;kver&gt;</tt></b> is the kernel version.</li>
      </ul>
      <h2><font size="4"><a name="kernelversiondiffs"></a>Building drivers </font></h2>

      <p>The buildLiS script will create &quot;streams.ko&quot; drivers in the <font face="Courier New, Courier, mono">/usr/src/LiS/km26/</font> 
      directory. At the end of the buildLiS script, the streams*.ko files are copied to the Misc modules directory,
      <tt><font face="Courier New, Courier, mono">/lib/modules/</font></tt><b><tt>&lt;kver&gt;</tt></b><tt><font face="Courier New, Courier, mono">/misc/</font></tt>.
      <h2><font size="4">Unconfig</font><font size="4">ured drivers and modules</font></h2>
      <p>An unconfigured driver or module is a driver or module that CSLiS does 
        not have any special information about. Even in this case, you can take 
        advantage of demand loading. </p>
      <h3>Modules</h3>
      <p>Module demand loading is simple. When a user does an <font face="Courier New, Courier, mono">I_PUSH 
        </font>requesting that module <tt><font face="Courier New, Courier, mono">mymod</font></tt> 
        be pushed onto a stream, CSLiS will check if <tt><font face="Courier New, Courier, mono">mymod</font></tt> 
        is already registered. If not, CSLiS asks the kernel to load <tt>streams-<font face="Courier New, Courier, mono">mymod</font></tt>. 
      </p>
      <p>A security related implication of this is that any user capable of doing 
        an <font face="Courier New, Courier, mono">I_PUSH</font> can provoke loading 
        of any module that has the <tt>streams-</tt> prefix. </p>
      <p>Demand loading also works when autopushing modules, but you should be 
        aware that when a module is unloaded, it is silently removed from all 
        autopush lists. </p>
      <p>You can have more than one module in a single kernel loadable module, 
        but for demand loading to work with modules whose object names are not 
        derived from the module name, you have to set up <tt>alias</tt> lines 
        in <tt>/etc/conf.modules</tt>. <br>
        For example, if you have modules <tt><font face="Courier New, Courier, mono">mymod</font></tt> 
        and <tt><font face="Courier New, Courier, mono">mymod2</font></tt> in 
        the kernel loadable object file <tt>streams-mymod.o</tt>, you have to 
        add the line </p>
      <blockquote> 
        <p><tt>alias streams-<font face="Courier New, Courier, mono">mymod2</font> 
          streams-<font face="Courier New, Courier, mono">mymod</font></tt></p>
      </blockquote>
      <p>in your <tt>/etc/conf.modules</tt> for demand loading to work properly 
        when pushing <tt><font face="Courier New, Courier, mono">mymod2</font></tt>. 
      </p>
      <h3>Drivers</h3>
      <p>Demand loading drivers is slightly more complicated. When a device special 
        node with major device number <b><tt>major</tt></b> is opened, the kernel 
        checks if device <b><tt>major</tt></b> is registered in the kernel. If 
        not, the kernel will try to load <tt>&quot;char-major-</tt><b><tt>major&quot;</tt></b>.</p>
      <p><br>
        If a clone open is done CSLiS will check if the driver is registered. If 
        not, CSLiS will ask the kernel to load <tt>char-major-</tt><b><tt>minor</tt></b>, 
        where <b><tt>minor</tt></b> is the minor device number of the clone device 
        opened. In this case the value of <b><tt>minor</tt></b> is the major device 
        number of the driver that needs to be loaded and opened.</p>
      <p>Kernel loadable modules generally do not have names of the form <tt>char-major-<b>number</b></tt>, 
        so a mapping to the correct name is needed. This is done with <tt>alias</tt> 
        lines in <tt>/etc/conf.modules</tt>, or, on newer systems, <tt>/etc/modules.conf</tt>. 
        If your driver has major device number <tt>123</tt> and is in the kernel 
        loadable object file <tt>streams-mydriver.o</tt>, you should have the 
        line </p>
      <blockquote> 
        <p><tt>alias char-major-123 streams-mydriver</tt></p>
      </blockquote>
      <p>in your <tt>/etc/conf.modules</tt>. </p>
      <p><br>
        If you also have the line </p>
      <blockquote> 
        <p><tt>alias char-major-240 streams</tt></p>
      </blockquote>
      <p>in your <tt>/etc/conf.modules</tt> and the clone driver major is 240, 
        both CSLiS and your driver will be demand loaded when you do a clone open 
        of your driver. </p>
      <p>You can configure autopush on an unconfigured driver, but you should 
        be aware that when the driver is unloaded, all its autopush lists are 
        silently removed. </p>
      <p>You can have more than one driver in a single kernel loadable module, 
        but you should set up a separate <tt>alias</tt> line for each driver. 
      </p>
      <h2><font size="4">Configured drivers and modules</font></h2>
      <p>When drivers and modules are added to the <a href="config.html#config_files">CSLiS 
        configuration files</a>, you can specify the object name that will be 
        used for requesting a demand load of the driver or module. If demand loading 
        of the configured object name fails, CSLiS will revert to the procedure 
        for demand loading an unconfigured driver or module.</p>
      <p><br>
        The advantage of configured drivers and modules is that the CSLiS installation 
        procedure takes care of adding the needed <tt>alias</tt> lines to <tt>/etc/conf.modules</tt>. 
        Also, the autopush configuration is not changed when a configured driver 
        or module is unloaded. </p>
      <h2><font size="4">Writing kernel loadable modules for CSLiS</font></h2>
      <p>It takes little extra effort to make CSLiS modules and drivers loadable. 
        In most cases, all you have to do is to add the special Linux module functions 
        <tt>init_module()</tt> and <tt>cleanup_module()</tt> and some lines to 
        maintain the usage count of the loadable module. </p>
      <p>The <tt>init_module()</tt> function id used for initializing the loadable 
        module, and can be as simple as: <tt>&nbsp;&nbsp;&nbsp; </tt></p>
      <pre><tt>  int init_module(void)</tt>   
 <tt> {</tt> <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>   
    <tt>return lis_register_strmod(&amp;mymod_info, &quot;mymod&quot;);</tt>  
  <tt>}</tt>        </pre>
      <p>for a module, or <tt>&nbsp;&nbsp;&nbsp; </tt></p>
      <pre><tt>  int init_module(void)
  {</tt>
    <tt>return lis_register_strdev(123,&amp;mydrv_info,</tt> <tt>10, &quot;mydrv&quot;);
  }</tt></pre>
      <p>for a driver.</p>
      <p>In this example, the driver's major device number is assumed to be 123. 
        You must know this major device number ahead of time so that you can make 
        the entry in the <font face="Courier New, Courier, mono">/dev</font> directory 
        that will cause your driver to autoload. The major number in your <font face="Courier New, Courier, mono">/dev</font> 
        entry and in your call to <font face="Courier New, Courier, mono"><tt>lis_register_strdev</tt></font> 
        must match.</p>
      <p>The <tt>cleanup_module()</tt> function is called by the kernel just before 
        a loadable module is unloaded. This function has to unregister the drivers 
        and/or modules registered in the <tt>init_module()</tt> function.</p>
      <p><br>
        The <tt>cleanup_module()</tt> function can be as simple as: <br>
        <tt>&nbsp;&nbsp;void cleanup_module(void)</tt> <br>
        <tt>&nbsp;&nbsp;{</tt> <br>
        <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lis_unregister_strmod(&amp;mymod_info);</tt> 
        <br>
        <tt>&nbsp;&nbsp;}</tt> <br>
        for a module, or <br>
        <tt>&nbsp;&nbsp;void cleanup_module(void)</tt> <br>
        <tt>&nbsp;&nbsp;{</tt> <br>
        <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lis_unregister_strdev(123);</tt> <br>
        <tt>&nbsp;&nbsp;}</tt> <br>
        for a driver. </p>
      <p>To avoid that the loadable module is unloaded while somebody is still 
        using it, a usage count has to be maintained. This is done using the macros 
        <tt>MOD_INC_USE_COUNT</tt> and <tt>MOD_DEC_USE_COUNT</tt>. <tt>MOD_INC_USE_COUNT</tt> 
        is used in the open routines, but be careful not to call it if your open 
        fails. <tt>MOD_DEC_USE_COUNT</tt> is used in the close routines. </p>
      <p>For a complete example, see the <a href="drvrs.html#link-drvr"><font face="Courier New, Courier, mono">ldl</font></a> 
        driver in <tt>drivers/str/linux/ldl.c</tt>. </p>
      <h3><a name="QueueLocking"></a>Queue Locking in Loadable Modules</h3>
      <p>Declared modules can use the <a href="config.html#QueueLockingSpecification">strconf 
        qlock option</a> to control the locking style for entering the driver's 
        put and service procedures. A loadable module can call one of the following 
        routines, most likely at module load time.</p>
      <pre>int lis_register_driver_qlock_option(major_t major, int qlock_option);
int lis_register_module_qlock_option(modID_t id, int qlock_option);        </pre>
      <p>The parameters <i>major</i> and <i>id</i> are obtained from the driver 
        and module registration functions described above.</p>
      <p>The <i>qlock_option</i> parameter is one of the following:</p>
      <table width="45%">
        <tr> 
          <td width="11%">&nbsp;</td>
          <td width="89%">LIS_QLOCK_NONE</td>
        </tr>
        <tr> 
          <td width="11%">&nbsp;</td>
          <td width="89%">LIS_QLOCK_QUEUE</td>
        </tr>
        <tr> 
          <td width="11%">&nbsp;</td>
          <td width="89%">LIS_QLOCK_QUEUE_PAIR</td>
        </tr>
        <tr> 
          <td width="11%">&nbsp;</td>
          <td width="89%">LIS_QLOCK_GLOBAL</td>
        </tr>
      </table>
      <p>&nbsp;</p>
      <p>&nbsp;</p>
    </td>

  </tr>

</table>

<p align="left">&nbsp;</p>



</body>



</html>



